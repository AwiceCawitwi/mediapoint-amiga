
;--- txed.a -------------------------------------------------------------+
; MediaPoint TextEdit Functions. Based on the original Macintosch        |
; TextEdit resource. Contains all assembly code needed to be able to     |
; perform the textedit functions quickly, called from a C routine.       |
;------------------------------------------------------------------------+
; DISCLAIMER: At the moment there is no guarantee that this code is 100% |
; correct and doesn't corrupt the system. Though much effort has been    |
; made to get it right, it's almost impossible to test for all possible  |
; situations. In fact, I may be totally out of my little mind !!         |
;------------------------------------------------------------------------+
; All programming by:                                                    |
;    Pascal Eeftinck, Bits On My Byte AudioVisual Entertainment          |
;------------------------------------------------------------------------+

; $VER: mediapoint/pascal/txed.a 01.060 (24/09/93)


	TTL	txed.a
	IDNT	txed.a


	INCDIR "include:"

	INCLUDE "exec/types.i"
	INCLUDE	"exec/tasks.i"
	INCLUDE	"exec/lists.i"
	INCLUDE "exec/nodes.i"
	INCLUDE	"exec/memory.i"
	INCLUDE "exec/strings.i"
	INCLUDE "exec/funcdef.i"
	INCLUDE "exec/exec_lib.i"
	INCLUDE	"exec/execbase.i"
	INCLUDE	"exec/libraries.i"
	INCLUDE "graphics/gfx.i"
	INCLUDE "graphics/text.i"
	INCLUDE	"graphics/clip.i"
	INCLUDE	"graphics/rastport.i"
	INCLUDE "graphics/graphics_lib.i"
	INCLUDE	"intuition/screens.i"
	INCLUDE "hardware/blit.i"

	INCDIR "pascal:include/"

	INCLUDE	"txed.i"
	INCLUDE	"macros.i"
	INCLUDE	"prefs.i"
	INCLUDE	"textstyles.i"
	INCLUDE	"stackvars.i"
	INCLUDE	"editwindow.i"
	INCLUDE	"antialias.i"


	xref	_SysBase
	xref	_GfxBase

	xref	_scrapBuffer
	xref	_undoBuffer
	xref	_CPrefs


	xref	_AntiAlias
	xref	GetTrueRGB
	xref	GetBestPen
	xref	GetAmountOfColors

*** MP_DEBUG	SET	1

	IFD	MP_DEBUG
	xref	KPrintF
	ENDC


	xdef	_TEInitInfo	; initialize TEInfo structure first time
	xdef	_TEInitWindow	; initialize TEFrame structure first time

	xdef	_TEKey		; insert typed character

	xdef	_TECut		; move selection to scrap
	xdef	_TECopy		; copy selection to scrap
	xdef	_TEPaste	; insert scrap into text at selStart
	xdef	_TEDelete	; remove selection range from text

	xdef	_TERemoveScrap	; remove scrap buffer from memory

	xdef	_TEActivate	; activate caret/selection range
	xdef	_TEDeactivate	; remove caret/selection range
	xdef	_TESetSelect	; set selection range / caret

	xdef	_TESetUpdateRange	; range, window, full

	xdef	_TESetJustification	; set justification mode for window
	xdef	_TESetShadow		; set shadow for window
	xdef	_TESetAntiAlias		; set antialias level for window
	xdef	_TESetItalic		; set italic values for window

	xdef	_TEUpdate	; update all frames in list as needed
	xdef	_TESetFont	; change selection range's font
	xdef	_TESetStyle	; change selection range's style
	xdef	_TESetColor	; change selection range's color

	xdef	_TEWhichBox	; where can we find this line ????

	xdef	_TEWhichLine	; report current line of caretstart
	xdef	_TEReportPos	; report position of caretstart
	xdef	_TECaretPos	; calculate position of caret relative
				; to window
	xdef	_TELineHeight	; returns total line height

	xdef	_TECreateUndo	; create undo buffer
	xdef	_TEPerformUndo	; restore and free undo buffer



;-------------------------------------------------------------------------
; func: VOID _TEUpdate(struct TEInfo *,textRP,maskBM,extraBM,extraRP,flag)
;-------------------------------------------------------------------------
; Redraw all that must be redrawn
;-------------------------------------------------------------------------

upd_TEInfo		equ	8
upd_textRP		equ	12
upd_maskBM		equ	16
upd_xtraBM		equ	20
upd_xtraRP		equ	24
upd_rdrw		equ	28

_TEUpdate

	link	a5,#0
	movem.l	d0-d7/a0-a4/a6,-(sp)

	movea.l	_GfxBase,a6
	movea.l	upd_TEInfo(a5),a3

	bsr.w	teRecalLines	; recalc linestarts if necessary

	moveq.l	#0,d2		; start update at first character

	movea.l	a3,a4
.tstnde	TSTNODE	a4,a4
	beq.w	.exit
	move.w	ew_TopMargin(a4),d1
	bsr.w	teExtraSpace
	move.w	d0,d5

.loop	cmp.w	ew_LastChar(a4),d2	; compare with last
	bge.w	.nxtnde

	move.w	d1,-(sp)
	bsr.w	teWhichCursorLine
	move.w	0(a0,d1.w),d2
	move.w	2(a0,d1.w),d3
	move.w	(sp)+,d1

	move.w	d3,-(sp)
	bsr.w	teCalcLineHeight
	move.w	(sp)+,d3

	cmp.w	tei_firstChanged(a3),d3
	bls.b	.do_not_display
	cmp.w	tei_lastChanged(a3),d2
	bhi.b	.do_not_display

.draw	move.w	ew_LeftMargin(a4),d0
	cmp.b	#JUSTIFICATION_LEFT,ew_justification(a4)
	beq.b	.dotext

.dojust	movem.w	d2-d3,-(sp)
	bsr.w	teCalcLineWidth
	move.w	ew_Width(a4),d2
	sub.w	ew_RightMargin(a4),d2
	cmp.b	#JUSTIFICATION_RIGHT,ew_justification(a4)
	beq.b	.justRI
.justCE	sub.w	ew_LeftMargin(a4),d2
	lsr.w	#1,d2
	add.w	ew_LeftMargin(a4),d2
	lsr.w	#1,d3
	sub.w	d3,d2
	move.w	d2,d0
	bra.b	.endjst
.justRI	sub.w	d3,d2
	move.w	d2,d0
.endjst	movem.w	(sp)+,d2-d3

.dotext	movea.l	upd_textRP(a5),a0
	movea.l	upd_maskBM(a5),a1
	movea.l	upd_xtraBM(a5),a2
	move.w	upd_rdrw+2(a5),d4
	move.l	upd_xtraRP(a5),-(sp)
	bsr.w	teText
	lea.l	4(sp),sp

.do_not_display
	move.w	d3,d2
	add.w	tei_lineHeight(a3),d1
	add.w	ew_ySpacing(a4),d1
	add.w	d5,d1
	bra.w	.loop

.exit	;tst.b	tei_fastUpdate(a3)
	;bne.b	.exit2
	clr.w	tei_lastChanged(a3)
	move.w	#TEXTEDITSIZE,tei_firstChanged(a3)
.exit2	movem.l	(sp)+,d0-d7/a0-a4/a6
	unlk	a5
	rts

;-----------------------------------------------------
.nxtnde	tst.w	upd_rdrw+2(a5)
	beq.w	.tstnde

	movem.w	d1-d6,-(sp)
	movea.l	ew_undoBM(a4),a0	; src bitmap
	movea.l	ew_rastPort(a4),a1	; dst rastport
	moveq.l	#0,d0			; srcx
	move.w	ew_X(a4),d2		; destx
	move.w	d1,d3
	add.w	ew_Y(a4),d3		; desty
	move.w	ew_Width(a4),d4		; sizex
	move.w	ew_Height(a4),d5
	sub.w	d1,d5			; sizey
	bmi.b	.stop
	beq.b	.stop
	move.w	#ABC+ABNC,d6		; minterm

	IFD	MP_DEBUG
	movem.l	d0-d1/a0-a1,-(sp)
	lea.l	un2wind,a0
	lea.l	data,a1
	move.w	d2,0(a1)
	move.w	d3,2(a1)
	move.w	d4,4(a1)
	move.w	d5,6(a1)
	jsr	KPrintF
	movem.l	(sp)+,d0-d1/a0-a1
	ENDC

	CALLLIB	_LVOBltBitMapRastPort

	IFD	MP_DEBUG
	movem.l	d0-d1/a0-a1,-(sp)
	lea.l	done,a0
	jsr	KPrintF
	movem.l	(sp)+,d0-d1/a0-a1
	ENDC


.stop	movem.w	(sp)+,d1-d6
	bra.w	.tstnde


 STACKSTRUCT
	_UWORD	txt_BLTSIZEW
	_UWORD	txt_BLTAFWM
	_UWORD	txt_BLTALWM
	_UWORD	txt_addX
	_UWORD	txt_dstYStart
	_BOOL	txt_redrawBgnd
	_APTR	txt_textRP
	_APTR	txt_textBM
	_APTR	txt_maskBM
	_APTR	txt_xtraBM
	_APTR	txt_xtraRP
	_APTR	txt_maskPlane
	_APTR	txt_editWindow
	_UWORD	txt_dstXStart
	_UWORD	txt_charStart
	_UWORD	txt_extraSpace
	_UWORD	txt_correction
	_STRUCT	txt_shdwBM,bm_SIZEOF
	_UWORD	txt_planesON
	_UBYTE	txt_sameColor
	_UBYTE	txt_prevColor
	_APTR	txt_gaussMem
	_APTR	txt_gaussMemSize
	_STRUCT	txt_aaInfo,aa_SIZEOF
	_STRUCT	txt_RGBtriplets,3*4*2
	_LABEL	txt_STCKSIZE


; VOID teText( (APTR) TEInfo (a3), (UWORD) from (d2), (UWORD) to (d3),
;		(UWORD) dstY (d1), (APTR) EditWindow (a4)
;		(APTR) textRP (a0), (APTR) maskBM (a1), (BOOL) rdrw (d4)
;		(APTR) extraBM (a2), (UWORD) extraSpace (d5) - taken by shadow
; draw all characters specified, complete with attributes for text etc.

teText	link	a5,#txt_STCKSIZE
	movem.l	d1/d3/d5/a4,-(sp)

	move.w	d1,txt_dstYStart(a5)
	move.w	d4,txt_redrawBgnd(a5)
	move.w	d5,txt_extraSpace(a5)
	move.l	a2,txt_xtraBM(a5)
	move.l	_1stParam(a5),txt_xtraRP(a5)

	move.l	a0,txt_textRP(a5)
	move.l	a1,txt_maskBM(a5)
	move.l	rp_BitMap(a0),a2
	move.l	a2,txt_textBM(a5)
	move.l	a4,txt_editWindow(a5)
	move.l	bm_Planes(a1),txt_maskPlane(a5)

	tst.b	ew_antiAliasLevel(a4)
	seq.b	txt_planesON(a5)
	sne.b	txt_sameColor(a5)

	movem.l	d0-d1/a0-a1,-(sp)
	movea.l	txt_textRP(a5),a1
	moveq.l	#0,d0
	CALLLIB	_LVOSetRast
	movem.l	(sp)+,d0-d1/a0-a1

	lsl.w	#tec_SHIFTSIZE,d2
	lsl.w	#tec_SHIFTSIZE,d3

	move.l	a0,-(sp)
	movea.l	tei_text(a3),a0
	move.b	tec_charColor(a0,d2.w),txt_prevColor(a5)
	move.l	(sp)+,a0

	moveq.l	#0,d7			; we start at plane 0

NextPlane
	movem.w	d0-d3,-(sp)
	movem.w	d0/d1,-(sp)
	CALLLIB	_LVOWaitBlit		; solve potential blitter problems
	movem.w	(sp)+,d0/d1

NextCH	cmp.w	d2,d3
	bls.w	Drawed

	movea.l	tei_text(a3),a0
	lea.l	(a0,d2.w),a1
	addq.w	#tec_SIZE,d2

	movea.l	tec_charFont(a1),a0

.offset	moveq.l	#0,d6
	move.b	tec_charCode(a1),d6
	move.b	tf_LoChar(a0),d4
	move.b	tf_HiChar(a0),d5
	cmp.b	d6,d4			; if LoChar > char
	bhi.b	.otble1
	cmp.b	d5,d6			; if char > HiChar
	bhi.b	.otble1
.itble1	sub.b	d4,d6			; char -= LoChar
	bra.b	.ofsdne
.otble1	sub.b	d4,d5
	addq.b	#1,d5
	move.b	d5,d6

.ofsdne	move.l	a3,-(sp)
	lsl.w	#1,d6

	move.w	d0,txt_charStart(a5)

	btst.b	#FPB_PROPORTIONAL,tf_Flags(a0)
	bne.b	.prop

.fixed	move.w	tf_XSize(a0),txt_addX(a5)
	movea.l	tf_CharKern(a0),a3
	cmpa.w	#0,a3
	beq.b	.both
	move.w	(a3,d6.w),d1
	add.w	d1,d0		; increase horizontal destx
	sub.w	d1,txt_addX(a5)
	bra.b	.both

.prop	movea.l	tf_CharKern(a0),a3
	cmpa.w	#0,a3
	beq.b	.skip00
	add.w	(a3,d6.w),d0		; increase horizontal destx
.skip00	movea.l	tf_CharSpace(a0),a3
	cmpa.w	#0,a3
	bne.b	.skip01
	move.w	tf_XSize(a0),txt_addX(a5)
	bra.b	.both
.skip01	move.w	(a3,d6.w),d4
	move.w	d4,txt_addX(a5)

.both	clr.w	txt_correction(a5)
	tst.w	d0
	bpl.b	.skip40
	neg.w	d0
	move.w	d0,txt_correction(a5)
	moveq.l	#0,d0
.skip40	lsl.w	#1,d6
	movea.l	tf_CharLoc(a0),a3
	move.w	0(a3,d6.w),d4		; charOffset
	add.w	txt_correction(a5),d4
	move.w	2(a3,d6.w),d5		; charBitWidth
	sub.w	txt_correction(a5),d5
	movea.l	(sp)+,a3
	beq.w	incPos			; if width 0, no display
	bmi.w	incPos

.tstdis	cmp.b	#31,tec_charCode(a1)	; skip display of control codes
	bls.w	incPos

; test whether this character needs to be placed into the plane
	btst.b	d7,tec_charColor(a1)
	beq.w	emptySp			; not even underlined

	movem.l	d0-d3/a3-a4,-(sp)
	move.b	tec_charColor(a1),d6
	or.b	d6,txt_planesON(a5)
	cmp.b	txt_prevColor(a5),d6
	beq.b	.skip99

	move.b	#FALSE,txt_sameColor(a5)

.skip99	addq.w	#1,d0
	clr.w	txt_dstXStart(a5)

	btst.b	#MFSB_ITALIC,tec_charStyle+1(a1)
	beq.b	.no_cor
	btst.b	#FSB_ITALIC,tf_Style(a0)
	bne.b	.no_cor

	move.w	tf_YSize(a0),d6
	sub.w	tf_Baseline(a0),d6
	neg.w	d6
	muls.w	ew_slantValue(a4),d6
	divs.w	ew_slantAmount(a4),d6
	add.w	d6,d0

	move.w	d0,txt_dstXStart(a5)
	bpl.b	.no_cor

	move.w	d0,d6
	move.w	bm_BytesPerRow(a2),d0
	cmpi.w	#38,LIB_VERSION(a6)
	bls.b	.nc002
	IsInterleaved	a2,a4
	bhi.b	.nc002

	ext.w	d0
	moveq.l	#0,d2
	move.b	bm_Depth(a2),d2
	divu.w	d2,d0
.nc002	lsl.w	#3,d0
	add.w	d6,d0

.no_cor	move.w	d7,d6
	lsl.w	#2,d6
	movea.l	bm_Planes(a2,d6.w),a4

	move.w	tei_baseLine(a3),d6
	add.w	tf_YSize(a0),d6
	sub.w	tf_Baseline(a0),d6
	tst.w	txt_dstXStart(a5)
	bpl.b	.nc001
	subq.w	#1,d6
.nc001	mulu.w	bm_BytesPerRow(a2),d6
	adda.l	d6,a4
	move.w	d0,d6
	andi.w	#$FFF0,d6
	lsr.w	#3,d6
	adda.w	d6,a4

	movea.l	tf_CharData(a0),a3
	move.w	tf_YSize(a0),d6
	subq.w	#1,d6
	mulu.w	tf_Modulo(a0),d6
	adda.l	d6,a3
	move.w	d4,d6
	andi.w	#$FFF0,d6
	lsr.w	#3,d6
	adda.w	d6,a3

	andi.w	#$000F,d4
	move.w	d4,d3
	andi.w	#$000F,d0
	cmp.w	d0,d3
	bls.b	.setval
	suba.w	#2,a4
	sub.w	d0,d3
	moveq.l	#16,d0
.setval	sub.w	d3,d0
	andi.w	#%00001111,d0

	move.w	d4,d2
	lsl.w	#1,d2
	move.w	maskFWM(pc,d2.w),txt_BLTAFWM(a5)
	add.w	d5,d2
	add.w	d5,d2
	andi.w	#%00011110,d2
	move.w	maskLWM(pc,d2.w),txt_BLTALWM(a5)

	add.w	d5,d4
	addi.w	#15,d4
	lsr.w	#4,d4
	move.w	d4,txt_BLTSIZEW(a5)
	subi.w	#1,txt_BLTSIZEW(a5)

	lsl.w	#1,d4
	move.w	d4,d5
	add.w	tf_Modulo(a0),d4
	add.w	bm_BytesPerRow(a2),d5

	move.w	tf_YSize(a0),d1
	subq.w	#1,d1

	tst.w	tec_charStyle(a1)
	beq.w	teBlitCharNormal
	bra.w	teBlitCharSpecial

maskFWM	dc.w	$ffff,$7fff,$3fff,$1fff,$0fff,$07ff,$03ff,$01ff
	dc.w	$00ff,$007f,$003f,$001f,$000f,$0007,$0003,$0001
maskLWM	dc.w	$ffff,$8000,$c000,$e000,$f000,$f800,$fc00,$fe00
	dc.w	$ff00,$ff80,$ffc0,$ffe0,$fff0,$fff8,$fffc,$fffe

;-------------------------------------------------------------------------
; the 'blit' functions returns at this label
;-------------------------------------------------------------------------
endBlit	movem.l	(sp)+,d0-d3/a3-a4

incPos	add.w	txt_addX(a5),d0
	add.w	ew_xSpacing(a4),d0

	btst.b	#MFSB_BOLD,tec_charStyle+1(a1)
	beq.b	.nobold
	btst.b	#FSB_BOLD,tf_Style(a0)
	bne.b	.nobold
	add.w	tf_BoldSmear(a0),d0
.nobold	btst.b	#MFSB_UNDERLINED,tec_charStyle+1(a1)
	beq.w	NextCH
	btst.b	#FSB_UNDERLINED,tf_Style(a0)
	bne.w	NextCH
	btst.b	d7,tec_charColor(a1)
	beq.w	NextCH
	cmp.b	#31,tec_charCode(a1)
	bls.w	NextCH

; the code below fills up the space under the character with an underline
; note: for now, no space is maintained between characters and underline

	move.b	tec_charColor(a1),d4
	or.b	d4,txt_planesON(a5)
	cmp.b	txt_prevColor(a5),d4
	beq.b	.skip99

	move.b	#FALSE,txt_sameColor(a5)

.skip99	move.w	txt_charStart(a5),d4		; for underline drawing

	movem.l	d1-d3/a1,-(sp)

	move.w	d7,d1
	lsl.w	#2,d1
	movea.l	bm_Planes(a2,d1.w),a1
	move.w	tei_baseLine(a3),d1
	addq.w	#2,d1
	add.w	ew_underLineOffset(a4),d1
	mulu.w	bm_BytesPerRow(a2),d1
	adda.w	d1,a1
	move.w	d4,d6
	lsr.w	#3,d6
	adda.w	d6,a1

	moveq.l	#7,d3
	move.w	d4,d1
	andi.w	#%00000111,d1
	sub.w	d1,d3

	move.w	ew_underLineHeight(a4),d2

	move.w	tei_lineHeight(a3),d5
	add.w	ew_ySpacing(a4),d5
	sub.w	tei_baseLine(a3),d5
	sub.w	ew_underLineOffset(a4),d5

	cmp.w	d2,d5
	bhi.b	.under
	move.w	d5,d2

.under	movem.l	d3/d4/a1,-(sp)
.underl	bset.b	d3,(a1)
	subq.w	#1,d3
	bpl.b	.skip03
	moveq.l	#7,d3
	adda.w	#1,a1
.skip03	addq.w	#1,d4
	cmp.w	d0,d4
	bls.b	.underl
	movem.l	(sp)+,d3/d4/a1
	adda.w	bm_BytesPerRow(a2),a1
	subq.w	#1,d2
	cmp.w	#1,d2
	bge.b	.under

.skip04	movem.l	(sp)+,d1-d3/a1
	bra.w	NextCH



emptySp	add.w	txt_addX(a5),d0
	add.w	ew_xSpacing(a4),d0
	btst.b	#MFSB_BOLD,tec_charStyle+1(a1)
	beq.w	NextCH
	btst.b	#FSB_BOLD,tf_Style(a0)
	bne.w	NextCH
	add.w	tf_BoldSmear(a0),d0
	bra.w	NextCH

Drawed	movem.w	(sp)+,d0-d3
	addq.w	#1,d7
	cmp.b	bm_Depth(a2),d7
	bne.w	NextPlane

	tst.b	ew_antiAliasLevel(a4)
	beq.w	noAntiAlias

	bsr.w	teCreateMask

	movem.l	d0-d7/a0-a4,-(sp)
	moveq.l	#0,d0
	move.w	ew_Width(a4),d0
	addq.w	#2,d0
	lsl.w	#2,d0
	moveq.l	#0,d1
	move.w	tei_lineHeight(a3),txt_aaInfo+aa_Height(a5)
	move.l	txt_maskPlane(a5),txt_aaInfo+aa_SrcMaskPlane(a5)
	movea.l	txt_textBM(a5),a0
	move.l	a0,txt_aaInfo+aa_SrcBitMap(a5)
	move.b	bm_Depth(a0),d1
	move.w	d2,-(sp)
	moveq.l	#4,d2
	lsl.l	d1,d2
	add.l	d2,d0
	addq.l	#4,d0
	move.w	(sp)+,d2
	move.l	d0,txt_aaInfo+aa_DataSize(a5)
	move.l	#MEMF_CLEAR,d1
	LINKLIB	_LVOAllocMem,_SysBase
	move.l	d0,txt_aaInfo+aa_Data(a5)
	beq.w	.exit

.Init	move.w	ew_Width(a4),d0
	addq.w	#2,d0
	move.w	d0,txt_aaInfo+aa_CacheLineSize(a5)
	movea.l	txt_aaInfo+aa_Data(a5),a0
	adda.w	#1,a0
	move.l	a0,txt_aaInfo+aa_CacheU(a5)
	adda.w	d0,a0
	move.l	a0,txt_aaInfo+aa_CacheM(a5)
	adda.w	d0,a0
	move.l	a0,txt_aaInfo+aa_CacheL(a5)
	adda.w	d0,a0
	move.l	a0,txt_aaInfo+aa_Storage(a5)
	adda.w	d0,a0
	suba.w	#1,a0
	move.l	a0,txt_aaInfo+aa_ColorConversion(a5)
	lea.l	_CPrefs,a1
	move.l	cp_PageScreenModes(a1),txt_aaInfo+aa_ViewModes(a5)
	lea.l	txt_aaInfo(a5),a0
	jsr	GetAmountOfColors

.loop00	cmp.w	d2,d3
	bls.w	.lpend
	movem.w	d2/d3,-(sp)

	movea.l	tei_text(a3),a1
	movea.l	txt_aaInfo+aa_ColorConversion(a5),a2

	cmp.b	#31,tec_charCode(a1,d2.w)	
	bls.w	.skip05

.loop01	move.b	(a2),d0
	beq.b	.skip03
	cmp.b	tec_charColor(a1,d2.w),d0
	beq.w	.skip05
	adda.w	#4,a2
	bra.b	.loop01

.skip03	lea.l	_CPrefs,a0
	movea.l	cp_PageCM(a0),a0
	moveq.l	#0,d0
	move.b	tec_charColor(a1,d2.w),d0
	move.b	d0,(a2)+
	lea.l	txt_RGBtriplets(a5),a1
	movea.l	txt_aaInfo+aa_ViewModes(a5),d1
	move.l	d1,d2
	move.l	d1,-(sp)
	jsr	GetTrueRGB
	move.l	(sp)+,d1

	moveq.l	#0,d0
	tst.w	ew_BackFillType(a4)
	bne.b	.doIt
	move.w	ew_BackFillColor(a4),d0

.doIt	lea.l	txt_RGBtriplets+[3*4](a5),a1
	jsr	GetTrueRGB

	moveq.l	#0,d4
	moveq.l	#0,d5
	moveq.l	#0,d6
	moveq.l	#0,d7
	lea.l	txt_RGBtriplets(a5),a1
	move.w	0(a1),d4
	move.w	4(a1),d5
	move.w	8(a1),d6
	move.w	[3*4]+0(a1),d7
	sub.l	d7,d4
	move.w	[3*4]+4(a1),d7
	sub.l	d7,d5
	move.w	[3*4]+8(a1),d7
	sub.l	d7,d6

	asr.l	#2,d4
	asr.l	#2,d5
	asr.l	#2,d6

	move.l	0+[3*4](a1),0(a1)
	move.l	4+[3*4](a1),4(a1)
	move.l	8+[3*4](a1),8(a1)

	add.w	d4,0(a1)
	add.w	d5,4(a1)
	add.w	d6,8(a1)

	move.b	-1(a2),d0
	movea.l	txt_aaInfo+aa_PaletteSize(a5),d1

	move.l	d0,-(sp)
	jsr	GetBestPen
	move.b	d0,(a2)+
	move.l	(sp)+,d0

	add.w	d4,0(a1)
	add.w	d5,4(a1)
	add.w	d6,8(a1)

	move.l	d0,-(sp)
	jsr	GetBestPen
	move.b	d0,(a2)+
	move.l	(sp)+,d0

	add.w	d4,0(a1)
	add.w	d5,4(a1)
	add.w	d6,8(a1)

	move.l	d0,-(sp)
	jsr	GetBestPen
	move.b	d0,(a2)+
	move.l	(sp)+,d0

.skip05	movem.w	(sp)+,d2/d3
	addq.w	#tec_SIZE,d2
	bra.w	.loop00


.lpend	pea.l	txt_aaInfo(a5)
	jsr	_AntiAlias
	lea.l	4(sp),sp

.free	movea.l	txt_aaInfo+aa_Data(a5),a1
	move.l	txt_aaInfo+aa_DataSize(a5),d0
	LINKLIB	_LVOFreeMem,_SysBase
.exit	movem.l	(sp)+,d0-d7/a0-a4

noAntiAlias
	bsr.w	teCreateMask

	tst.w	txt_redrawBgnd(a5)
	beq.w	Update			; if FALSE, update
	bra.w	Edit			; if TRUE, edit

Render	tst.b	ew_shadowType(a4)
	beq.w	teShadowTypeNormal

	movea.l	txt_maskBM(a5),a0
	lea.l	txt_shdwBM(a5),a1
	moveq.l	#bm_SIZEOF-1,d0
.copy	move.b	(a0,d0.w),(a1,d0.w)
	dbra	d0,.copy
	move.l	bm_Planes+[0*4](a0),d0
	move.l	bm_Planes+[1*4](a0),d1
	moveq.l	#0,d6			; clear bitcounter
	moveq.l	#0,d7			; clear planecounter
	movea.l	txt_textBM(a5),a2
	move.b	bm_Depth(a2),d7
	move.b	d7,bm_Depth(a1)
	lea.l	bm_Planes(a1),a2

	move.w	ew_BackFillColor(a4),d5
	cmp.b	#SHADOWTYPE_TRANSPARENT,ew_shadowType(a4)
	beq.b	.skip44
	move.b	ew_shadowPen(a4),d5

.skip44	btst.l	d6,d5
	beq.b	.clrpl
.mskpl	move.l	d0,(a2)+		; set mask plane
	bra.b	.skip42
.clrpl	move.l	d1,(a2)+		; set cleared plane
.skip42	addq.w	#1,d6			; increase bitcounter
	cmp.w	d6,d7			; last of planes?
	bhi.b	.skip44			; if not, repeat

.skip50	cmp.b	#SHADOWTYPE_CAST,ew_shadowType(a4)
	beq.w	teShadowTypeCast
	cmp.b	#SHADOWTYPE_SOLID,ew_shadowType(a4)
	beq.w	teShadowTypeSolid
	cmp.b	#SHADOWTYPE_OUTLINE,ew_shadowType(a4)
	beq.w	teShadowTypeOutline
	cmp.b	#SHADOWTYPE_TRANSPARENT,ew_shadowType(a4)
	beq.w	teShadowTypeTransparent
	bra.w	teShadowTypeNormal

txt_xit	movem.l	(sp)+,d1/d3/d5/a4
	unlk	a5
	rts


*******************************************************************
Update	movea.l	ew_rastPort(a4),a0	; src rastport
	movea.l	txt_xtraRP(a5),a1	; dst rastport
	moveq.l	#0,d0			; srcx
	move.w	txt_dstYStart(a5),d1	; srcy
	moveq.l	#0,d2			; dstx
	move.w	d1,d3			; dsty
	add.w	ew_X(a4),d0
	add.w	ew_Y(a4),d1
	move.w	ew_Width(a4),d4		; sizex
	move.w	tei_lineHeight(a3),d5
	add.w	txt_extraSpace(a5),d5
	add.w	ew_ySpacing(a4),d5	; sizey
	movea.l	rp_BitMap(a1),a2
	move.w	bm_Rows(a2),d6
	cmp.w	d3,d6
	ble.w	Render
	sub.w	d3,d6
	cmp.w	d5,d6
	bhi.b	.go_on
	move.w	d6,d5
.go_on	tst.w	d5
	beq.w	Render
	bmi.w	Render
	move.w	#$C0,d6			; minterm
	CALLLIB	_LVOClipBlit
	bra.w	Render
*******************************************************************



*******************************************************************
Edit	movea.l	ew_undoBM(a4),a0	; src bitmap
	movea.l	txt_xtraBM(a5),a1	; dst bitmap
	moveq.l	#0,d0			; srcx
	move.w	txt_dstYStart(a5),d1	; srcy
	moveq.l	#0,d2			; dstx
	move.w	d1,d3			; dsty
	move.w	ew_Width(a4),d4		; sizex
	move.w	tei_lineHeight(a3),d5
	add.w	txt_extraSpace(a5),d5
	add.w	ew_ySpacing(a4),d5	; sizey
	move.w	bm_Rows(a1),d6
	cmp.w	d3,d6
	ble.w	Render
	sub.w	d1,d6
	cmp.w	d5,d6
	bhi.b	.go_on
	move.w	d6,d5
.go_on	tst.w	d5
	beq.w	Render
	bmi.w	Render
	move.w	#$C0,d6			; minterm
	move.w	#$FF,d7			; mask
	suba.l	a2,a2
	CALLLIB	_LVOBltBitMap
	bra.w	Render
*******************************************************************

	IFD	MP_DEBUG
un2xtra	dc.b	"Undo > XtraBM  X:%d  Y:%d  W:%d  H:%d",0
un2wind	dc.b	"Undo > ew->RastPort  X:%d  Y:%d  W:%d  H:%d",0
tx2xtra	dc.b	"Text > XtraBM  X:%d  Y:%d  W:%d  H:%d",0
xt2wind	dc.b	"Xtra > ew->RastPort  X:%d  Y:%d  W:%d  H:%d",0
done	dc.b	" ... Operation completed",10,0
	even
data	dc.w	0,0,0,0,0,0
	ENDC



teShadowTypeNormal
	movea.l	txt_textBM(a5),a0	; src bm
	movea.l	txt_xtraRP(a5),a1	; dst rp
	moveq.l	#1,d0			; src x
	moveq.l	#1,d1			; src y
	moveq.l	#0,d2			; dst x
	move.w	txt_dstYStart(a5),d3	; dst y
	move.w	ew_Width(a4),d4		; size x
	move.w	tei_lineHeight(a3),d5	; size y
	tst.w	d5
	beq.w	Final
	bmi.w	Final
	movea.l	rp_BitMap(a1),a2	; dst bm
	move.w	bm_Rows(a2),d6
	sub.w	d3,d6
	beq.w	Final
	bmi.w	Final
	cmp.w	d6,d5
	bgt.w	Final
	move.w	#ABC+ABNC+ANBC,d6	; minterm D = AB + AC
	movea.l	txt_maskPlane(a5),a2	; maskplane
	CALLLIB	_LVOBltMaskBitMapRastPort
	bra.w	Final


teShadowTypeCast
	lea.l	teDirectionTable(pc),a2
	move.b	ew_shadowDirection(a4),d7
	ext.w	d7
	lsl.w	#2,d7
	lea.l	(a2,d7.w),a2

	move.b	ew_shadowDepth(a4),d6
	ext.w	d6
	addq.w	#1,d6

	lea.l	txt_shdwBM(a5),a0	; src bm
	moveq.l	#0,d2			; dst x
	move.w	txt_dstYStart(a5),d3	; dst y
	movea.l	txt_xtraRP(a5),a1	; dst rp
	moveq.l	#1,d0			; src x
	moveq.l	#1,d1			; src y
	move.w	ew_Width(a4),d4
	sub.w	d6,d4			; size x
	move.w	tei_lineHeight(a3),d5	; size y
	tst.w	d5
	beq.w	Final
	bmi.w	Final

.xoff1	tst.w	0(a2)
	beq.b	.yoff1
	bmi.b	.xoff1n

.xoff1p	add.w	d6,d2
	bra.b	.yoff1

.xoff1n	add.w	d6,d0


.yoff1	tst.w	2(a2)
	beq.b	.blit1
	bmi.b	.yoff1n

.yoff1p	add.w	d6,d3
	bra.b	.blit1

.yoff1n	move.w	d0,-(sp)
	move.b	ew_shadowDepth(a4),d0
	ext.w	d0
	add.w	d0,d3
	sub.w	d6,d3
	move.w	(sp)+,d0

.blit1	movem.l	d6/a2,-(sp)
	move.w	#ABC+ABNC+ANBC,d6	; minterm
	movea.l	txt_maskPlane(a5),a2	; maskplane
	CALLLIB	_LVOBltMaskBitMapRastPort
	movem.l	(sp)+,d6/a2

.blit2	movea.l	txt_textBM(a5),a0	; src bm
	moveq.l	#0,d2			; dst x
	move.w	txt_dstYStart(a5),d3	; dst y
	movea.l	txt_xtraRP(a5),a1	; dst rp
	moveq.l	#1,d0			; src x
	moveq.l	#1,d1			; src y
	move.w	ew_Width(a4),d4		; size x
	move.w	tei_lineHeight(a3),d5	; size y
	tst.w	d5
	beq.w	Final
	bmi.w	Final

	tst.w	2(a2)
	bge.b	.blit3
	move.b	ew_shadowDepth(a4),d7
	ext.w	d7
	add.w	d7,d3
	
.blit3	move.w	#ABC+ABNC+ANBC,d6	; minterm
	movea.l	txt_maskPlane(a5),a2	; maskplane
	CALLLIB	_LVOBltMaskBitMapRastPort
	bra.w	Final




teShadowTypeSolid
	lea.l	teDirectionTable(pc),a2
	move.b	ew_shadowDirection(a4),d7
	ext.w	d7
	lsl.w	#2,d7
	lea.l	(a2,d7.w),a2

	move.b	ew_shadowDepth(a4),d7
	ext.w	d7
	moveq.l	#1,d6

.loop	lea.l	txt_shdwBM(a5),a0	; src bm
	moveq.l	#0,d2			; dst x
	move.w	txt_dstYStart(a5),d3	; dst y

	movea.l	txt_xtraRP(a5),a1	; dst rp
	moveq.l	#1,d0			; src x
	moveq.l	#1,d1			; src y
	move.w	ew_Width(a4),d4
	sub.w	d6,d4			; size x
	move.w	tei_lineHeight(a3),d5	; size y
	tst.w	d5
	beq.w	Final
	bmi.w	Final

.xoff1	tst.w	0(a2)
	beq.b	.yoff1
	bmi.b	.xoff1n

.xoff1p	add.w	d6,d2
	bra.b	.yoff1

.xoff1n	add.w	d6,d0


.yoff1	tst.w	2(a2)
	beq.b	.blit1
	bmi.b	.yoff1n

.yoff1p	add.w	d6,d3
	bra.b	.blit1

.yoff1n	move.w	d0,-(sp)
	move.b	ew_shadowDepth(a4),d0
	ext.w	d0
	add.w	d0,d3
	sub.w	d6,d3
	move.w	(sp)+,d0


.blit1	movem.l	d6/a2,-(sp)
	move.w	#ABC+ABNC+ANBC,d6	; minterm
	movea.l	txt_maskPlane(a5),a2	; maskplane
	CALLLIB	_LVOBltMaskBitMapRastPort
	movem.l	(sp)+,d6/a2

	addq.w	#1,d6
	dbra	d7,.loop

.blit2	movea.l	txt_textBM(a5),a0	; src bm
	moveq.l	#0,d2			; dst x
	move.w	txt_dstYStart(a5),d3	; dst y
	movea.l	txt_xtraRP(a5),a1	; dst rp
	moveq.l	#1,d0			; src x
	moveq.l	#1,d1			; src y
	move.w	ew_Width(a4),d4		; size x
	move.w	tei_lineHeight(a3),d5	; size y
	tst.w	d5
	beq.w	Final
	bmi.w	Final

	tst.w	2(a2)
	bge.b	.blit3
	move.b	ew_shadowDepth(a4),d7
	ext.w	d7
	add.w	d7,d3
	
.blit3	move.w	#ABC+ABNC+ANBC,d6	; minterm
	movea.l	txt_maskPlane(a5),a2	; maskplane
	CALLLIB	_LVOBltMaskBitMapRastPort
	bra.w	Final



teShadowTypeOutline
	move.w	#ABC+ABNC+ANBC,d6	; minterm
	movea.l	txt_maskPlane(a5),a2	; maskplane
	move.w	tei_lineHeight(a3),d5	; size y
	tst.w	d5
	beq.w	Final
	bmi.w	Final

	;tst.b	tei_fastUpdate(a3)
	;bne.b	.last

	bsr.b	.init
	subq.w	#1,d4
	addq.w	#1,d0
	CALLLIB	_LVOBltMaskBitMapRastPort

	bsr.b	.init
	CALLLIB	_LVOBltMaskBitMapRastPort

	bsr.b	.init
	subq.w	#1,d4
	addq.w	#1,d2
	CALLLIB	_LVOBltMaskBitMapRastPort

	bsr.b	.init
	subq.w	#1,d4
	addq.w	#1,d0
	addq.w	#1,d3
	CALLLIB	_LVOBltMaskBitMapRastPort

	bsr.b	.init
	subq.w	#1,d4
	addq.w	#1,d2
	addq.w	#1,d3
	CALLLIB	_LVOBltMaskBitMapRastPort

	bsr.b	.init
	subq.w	#1,d4
	addq.w	#1,d0
	addq.w	#2,d3
	CALLLIB	_LVOBltMaskBitMapRastPort

	bsr.b	.init
	addq.w	#2,d3
	CALLLIB	_LVOBltMaskBitMapRastPort

	bsr.b	.init
	subq.w	#1,d4
	addq.w	#1,d2
	addq.w	#2,d3
	CALLLIB	_LVOBltMaskBitMapRastPort

.last	bsr.b	.init
	addq.w	#1,d3
	movea.l	txt_textBM(a5),a0
	CALLLIB	_LVOBltMaskBitMapRastPort
	bra.w	Final

.init	lea.l	txt_shdwBM(a5),a0	; src bm
	moveq.l	#0,d2			; dst x
	move.w	txt_dstYStart(a5),d3	; dst y
	movea.l	txt_xtraRP(a5),a1	; dst rp
	moveq.l	#1,d0			; src x
	moveq.l	#1,d1			; src y
	move.w	ew_Width(a4),d4		; size x
	rts





teShadowTypeTransparent
	move.w	#ABC+ABNC+ANBC,d6	; minterm
	movea.l	txt_maskPlane(a5),a2	; maskplane
	move.w	tei_lineHeight(a3),d5	; size y
	tst.w	d5
	beq.w	Final
	bmi.w	Final

	;tst.b	tei_fastUpdate(a3)
	;bne.b	.last

	bsr.w	.init
	subq.w	#1,d4
	addq.w	#1,d0
	CALLLIB	_LVOBltMaskBitMapRastPort

	bsr.w	.init
	CALLLIB	_LVOBltMaskBitMapRastPort

	bsr.w	.init
	subq.w	#1,d4
	addq.w	#1,d2
	CALLLIB	_LVOBltMaskBitMapRastPort

	bsr.w	.init
	subq.w	#1,d4
	addq.w	#1,d0
	addq.w	#1,d3
	CALLLIB	_LVOBltMaskBitMapRastPort

	bsr.b	.init
	subq.w	#1,d4
	addq.w	#1,d2
	addq.w	#1,d3
	CALLLIB	_LVOBltMaskBitMapRastPort

	bsr.b	.init
	subq.w	#1,d4
	addq.w	#1,d0
	addq.w	#2,d3
	CALLLIB	_LVOBltMaskBitMapRastPort

	bsr.b	.init
	addq.w	#2,d3
	CALLLIB	_LVOBltMaskBitMapRastPort

	bsr.b	.init
	subq.w	#1,d4
	addq.w	#1,d2
	addq.w	#2,d3
	CALLLIB	_LVOBltMaskBitMapRastPort


.last	bsr.b	.init
	addq.w	#1,d3
	lea.l	txt_shdwBM(a5),a0
	CALLLIB	_LVOBltMaskBitMapRastPort

	bra.w	Final

.init	movea.l	txt_textBM(a5),a0	; src bm
	moveq.l	#0,d2			; dst x
	move.w	txt_dstYStart(a5),d3	; dst y
	movea.l	txt_xtraRP(a5),a1	; dst rp
	moveq.l	#1,d0			; src x
	moveq.l	#1,d1			; src y
	move.w	ew_Width(a4),d4		; size x
	rts


Final	movea.l	txt_xtraBM(a5),a0	; src bitmap
	movea.l	ew_rastPort(a4),a1	; dst rastport
	moveq.l	#0,d0			; srcx
	move.w	txt_dstYStart(a5),d1	; srcy
	moveq.l	#0,d2			; dstx
	move.w	d1,d3			; dsty
	move.w	ew_Width(a4),d4		; sizex
	move.w	tei_lineHeight(a3),d5
	add.w	txt_extraSpace(a5),d5
	add.w	ew_ySpacing(a4),d5	; sizey
	move.w	#$C0,d6			; minterm
	bsr.b	PrepareBlit
	add.w	ew_X(a4),d2
	add.w	ew_Y(a4),d3
	tst.w	d5
	beq.w	txt_xit
	bmi.w	txt_xit

	IFD	MP_DEBUG
	movem.l	d0-d1/a0-a1,-(sp)
	lea.l	xt2wind,a0
	lea.l	data,a1
	move.w	d2,0(a1)
	move.w	d3,2(a1)
	move.w	d4,4(a1)
	move.w	d5,6(a1)
	jsr	KPrintF
	movem.l	(sp)+,d0-d1/a0-a1
	ENDC

	CALLLIB	_LVOBltBitMapRastPort

	IFD	MP_DEBUG
	movem.l	d0-d1/a0-a1,-(sp)
	lea.l	done,a0
	jsr	KPrintF
	movem.l	(sp)+,d0-d1/a0-a1
	ENDC

	bra.w	txt_xit


PrepareBlit
	movem.w	d6-d7,-(sp)
	move.w	ew_Width(a4),d6
	sub.w	d2,d6			; remaining x-space
	sub.w	d4,d6
	bpl.b	.skip00
	add.w	d6,d4
.skip00	move.w	ew_Height(a4),d6
	sub.w	d3,d6			; remaining y-space
	sub.w	d5,d6
	bpl.b	.skip01
	add.w	d6,d5
.skip01	movem.w	(sp)+,d6-d7
	rts


;----------------------------------------------------------------------------
; place character data in plane pointed to by _BLTCDPTR
;----------------------------------------------------------------------------

teBlitCharNormal
	move.w	txt_BLTSIZEW(a5),d6
	beq.b	OneWordMode
	cmpi.w	#1,d6
	beq.b	TwoWordsMode

.BLTLPY	moveq.l	#0,d3			; clearance of old value (shifter A)
	move.w	txt_BLTSIZEW(a5),d6
;------------------------------------------
.BLTLPX	move.l	d3,d2
	move.w	(a3)+,d2

	cmp.w	txt_BLTSIZEW(a5),d6
	bne.b	.NO_FWM
	and.w	txt_BLTAFWM(a5),d2
.NO_FWM	tst.w	d6
	bne.b	.SHIFT
	and.w	txt_BLTALWM(a5),d2

.SHIFT	move.l	d2,d3			; store for later fetch
	swap.w	d3
	ror.l	d0,d2			; simulate barrel shifter A
	or.w	d2,(a4)+
	dbra	d6,.BLTLPX
;------------------------------------------
	clr.w	d3
	tst.l	d3
	beq.b	.MODULO
	ror.l	d0,d3
	or.w	d3,(a4)

.MODULO	suba.w	d4,a3
	suba.w	d5,a4
	dbra	d1,.BLTLPY
	bra.w	endBlit
;----------------------------------------------------------------------------

OneWordMode
.BLTLPY	moveq.l	#0,d3			; clearance of old value (shifter A)
;------------------------------------------
.BLTLPX	move.l	d3,d2
	move.w	(a3)+,d2
	and.w	txt_BLTAFWM(a5),d2
	and.w	txt_BLTALWM(a5),d2
	move.l	d2,d3			; store for later fetch
	swap.w	d3
	ror.l	d0,d2			; simulate barrel shifter A
	or.w	d2,(a4)+
;------------------------------------------
	clr.w	d3
	tst.l	d3
	beq.b	.MODULO
	ror.l	d0,d3
	or.w	d3,(a4)

.MODULO	suba.w	d4,a3
	suba.w	d5,a4
	dbra	d1,.BLTLPY
	bra.w	endBlit
;----------------------------------------------------------------------------

TwoWordsMode
.BLTLPY	moveq.l	#0,d3			; clearance of old value (shifter A)
;------------------------------------------
	move.l	d3,d2
	move.w	(a3)+,d2
	and.w	txt_BLTAFWM(a5),d2
	move.l	d2,d3			; store for later fetch
	swap.w	d3
	ror.l	d0,d2			; simulate barrel shifter A
	or.w	d2,(a4)+

	move.l	d3,d2
	move.w	(a3)+,d2
	and.w	txt_BLTALWM(a5),d2
	move.l	d2,d3			; store for later fetch
	swap.w	d3
	ror.l	d0,d2			; simulate barrel shifter A
	or.w	d2,(a4)+
;------------------------------------------
	clr.w	d3
	tst.l	d3
	beq.b	.MODULO
	ror.l	d0,d3
	or.w	d3,(a4)

.MODULO	suba.w	d4,a3
	suba.w	d5,a4
	dbra	d1,.BLTLPY
	bra.w	endBlit
;----------------------------------------------------------------------------





teBlitCharSpecial
	movem.l	d7/a6,-(sp)
	movea.l	txt_editWindow(a5),a6
	movem.l	d0-d1/a3-a4,-(sp)

	moveq.l	#0,d7
.BLTLPY	moveq.l	#0,d3			; clearance of old value (shifter A)
	move.w	txt_BLTSIZEW(a5),d6
;------------------------------------------
.BLTLPX	move.l	d3,d2
	move.w	(a3)+,d2

	cmp.w	txt_BLTSIZEW(a5),d6
	bne.b	.NO_FWM
	and.w	txt_BLTAFWM(a5),d2

.NO_FWM	tst.w	d6
	bne.b	.SHIFT
	and.w	txt_BLTALWM(a5),d2

.SHIFT	move.l	d2,d3			; store for later fetch
	swap.w	d3
	ror.l	d0,d2			; simulate barrel shifter A
	or.w	d2,(a4)+
	dbra	d6,.BLTLPX
;------------------------------------------
	clr.w	d3
	tst.l	d3
	beq.b	.MODULO
	ror.l	d0,d3
	or.w	d3,(a4)

.MODULO	suba.w	d4,a3
	suba.w	d5,a4

	btst.b	#MFSB_ITALIC,tec_charStyle+1(a1)
	beq.b	.TSTLP
	btst.b	#FSB_ITALIC,tf_Style(a0)
	bne.b	.TSTLP

	addq.w	#1,d7
	cmp.w	ew_slantAmount(a6),d7
	bne.b	.TSTLP

	moveq.l	#0,d7
	tst.w	ew_slantValue(a6)
	bmi.b	.neg2

.pos2	add.w	ew_slantValue(a6),d0	; shift further
	cmp.w	#16,d0			; when too far
	blt.b	.TSTLP
	sub.w	#16,d0			; then reset
	adda.w	#2,a4			; and take next word
	bra.b	.TSTLP

.neg2	add.w	ew_slantValue(a6),d0	; shift back
	bpl.b	.TSTLP
	add.w	#16,d0			; if too less then reset
	suba.w	#2,a4			; and take previous word

.TSTLP	dbra	d1,.BLTLPY

	movem.l	(sp)+,d0-d1/a3-a4

	btst.b	#MFSB_BOLD,tec_charStyle+1(a1)
	beq.w	.endblt
	btst.b	#FSB_BOLD,tf_Style(a0)
	bne.w	.endblt

	add.w	tf_BoldSmear(a0),d0	; shift further
	move.w	d0,d7
	andi.w	#$000F,d0
	andi.w	#$00F0,d7
	lsr.w	#3,d7
	adda.w	d7,a4	

	moveq.l	#0,d7
.BLTY02	moveq.l	#0,d3			; clearance of old value (shifter A)
	move.w	txt_BLTSIZEW(a5),d6
;------------------------------------------
.BLTX02	move.l	d3,d2
	move.w	(a3)+,d2

	cmp.w	txt_BLTSIZEW(a5),d6
	bne.b	.NOFWM2
	and.w	txt_BLTAFWM(a5),d2

.NOFWM2	tst.w	d6
	bne.w	.SHIFT2
	and.w	txt_BLTALWM(a5),d2

.SHIFT2	move.l	d2,d3			; store for later fetch
	swap.w	d3
	ror.l	d0,d2			; simulate barrel shifter A
	or.w	d2,(a4)+
	dbra	d6,.BLTX02
;------------------------------------------
	clr.w	d3
	tst.l	d3
	beq.b	.MODUL2
	ror.l	d0,d3
	or.w	d3,(a4)

.MODUL2	suba.w	d4,a3
	suba.w	d5,a4

	btst.b	#MFSB_ITALIC,tec_charStyle+1(a1)
	beq.b	.TSTLP2
	btst.b	#FSB_ITALIC,tf_Style(a0)
	bne.b	.TSTLP2
	addq.w	#1,d7

	cmp.w	ew_slantAmount(a6),d7
	bne.b	.TSTLP2

	moveq.l	#0,d7
	tst.w	ew_slantValue(a6)
	bmi.b	.neg

.pos	add.w	ew_slantValue(a6),d0	; shift further
	cmp.w	#16,d0			; when too far
	blt.b	.TSTLP2
	sub.w	#16,d0			; then reset
	adda.w	#2,a4			; and take next word
	bra.b	.TSTLP2

.neg	add.w	ew_slantValue(a6),d0	; shift back
	bpl.b	.TSTLP2
	add.w	#16,d0			; if too less then reset
	suba.w	#2,a4			; and take previous word

.TSTLP2	dbra	d1,.BLTY02

.endblt	movem.l	(sp)+,d7/a6
	bra.w	endBlit
;----------------------------------------------------------------------------



teDirectionTable
	dc.w	01,01		; south-east
	dc.w	00,01		; south
	dc.w	-1,01		; south-west
	dc.w	-1,00		;       west
	dc.w	-1,-1		; north-west
	dc.w	00,-1		; north
	dc.w	01,-1		; north-east
	dc.w	01,00		;       east



;----------------------------------------------------------------------------
; creates mask of BitMap (a2) in mask-BitMap
;----------------------------------------------------------------------------

teCreateMask
	movem.w	d0-d7,-(sp)
	move.l	bm_Planes(a2),-(sp)

	tst.b	ew_antiAliasLevel(a4)
	beq.b	.skip90
	move.b	#~0,txt_planesON(a5)
	move.b	#FALSE,txt_sameColor(a5)

.skip90	move.b	txt_planesON(a5),d5
	tst.b	d5
	beq.w	.zero
	cmp.b	#%00000001,d5
	beq.w	.zero

	moveq.l	#0,d6
	move.b	bm_Depth(a2),d6
	lsl.w	#2,d6

	moveq.l	#0,d7

.skip01	btst.l	#0,d5
	beq.b	.skip00

	movem.w	d5-d7,-(sp)
	movea.l	a2,a0			; SrcBM
	move.l	bm_Planes(a0,d7.w),bm_Planes(a0)
	movea.l	txt_maskBM(a5),a1	; DstBM
	moveq.l	#1,d0			; SrcX
	moveq.l	#1,d1			; SrcY
	moveq.l	#1,d2			; DstX
	moveq.l	#1,d3			; DstY
	move.w	ew_Width(a4),d4		; SizeX
	move.w	tei_lineHeight(a3),d5	;
	add.w	txt_extraSpace(a5),d5	;
	add.w	ew_ySpacing(a4),d5	; SizeY
	move.w	#$C0,d6			; Minterm D = A
	moveq.l	#%00000001,d7		; Mask
	CALLLIB	_LVOBltBitMap		; Do the blit
	movem.w	(sp)+,d5-d7
	addq.w	#4,d7
	bra.b	.do_nxt

.skip00	lsr.b	#1,d5
	addq.w	#4,d7
	bra.b	.skip01

.do_nxt	cmp.w	d7,d6
	bls.b	.exit
	tst.b	txt_sameColor(a5)
	bne.b	.exit

	btst.l	#0,d5
	beq.b	.skip10

	movem.w	d5-d7,-(sp)
	movea.l	a2,a0			; SrcBM
	move.l	bm_Planes(a0,d7.w),bm_Planes(a0)
	movea.l	txt_maskBM(a5),a1	; DstBM
	moveq.l	#1,d0			; SrcX
	moveq.l	#1,d1			; SrcY
	move.w	tei_lineHeight(a3),d5	;
	add.w	txt_extraSpace(a5),d5	;
	add.w	ew_ySpacing(a4),d5	; SizeY
	move.w	#$EA,d6			; Minterm D = ??
	moveq.l	#%00000001,d7		; Mask
	CALLLIB	_LVOBltBitMap		; Do the blit
	movem.w	(sp)+,d5-d7

.skip10	lsr.b	#1,d5
	addq.w	#4,d7
	bra.b	.do_nxt

.exit	move.l	(sp)+,bm_Planes(a2)
	movem.w	(sp)+,d0-d7
	rts


.zero	movea.l	a2,a0
	movea.l	txt_maskBM(a5),a1
	moveq.l	#1,d0			; SrcX
	moveq.l	#1,d1			; SrcY
	moveq.l	#1,d2			; DstX
	moveq.l	#1,d3			; DstY
	move.w	ew_Width(a4),d4		; SizeX
	move.w	tei_lineHeight(a3),d5	;
	add.w	txt_extraSpace(a5),d5	;
	add.w	ew_ySpacing(a4),d5	; SizeY
	move.w	#$C0,d6			; Minterm D = A
	moveq.l	#%00000001,d7		; Mask
	CALLLIB	_LVOBltBitMap		; Do the blit
	bra.b	.exit



;----------------------------------------------------------------------------
; creates inverted mask of BitMap (a2) in mask-BitMap, adjusts maskbitmap (*)
;  * restores old state, though
;----------------------------------------------------------------------------

teCreateInvertedMask
	movem.w	d0-d7,-(sp)

	move.l	bm_Planes(a2),-(sp)
	movea.l	txt_maskBM(a5),a1
	move.w	bm_BytesPerRow(a1),-(sp)

	movea.l	ew_undoBM(a4),a0
	move.w	bm_BytesPerRow(a0),bm_BytesPerRow(a1)

	move.b	txt_planesON(a5),d5
	tst.b	d5
	beq.w	.zero
	cmp.b	#%00000001,d5
	beq.w	.zero

	moveq.l	#0,d6
	move.b	bm_Depth(a2),d6
	lsl.w	#2,d6

	moveq.l	#0,d7

.skip01	btst.l	#0,d5
	beq.b	.skip00

	movem.w	d5-d7,-(sp)
	movea.l	a2,a0			; SrcBM
	move.l	bm_Planes(a0,d7.w),bm_Planes(a0)
	moveq.l	#1,d0			; SrcX
	moveq.l	#1,d1			; SrcY
	moveq.l	#0,d2			; DstX
	moveq.l	#0,d3			; DstY
	move.w	ew_Width(a4),d4		; SizeX
	move.w	tei_lineHeight(a3),d5	;
	add.w	txt_extraSpace(a5),d5	;
	add.w	ew_ySpacing(a4),d5	; SizeY
	move.w	#$30,d6			; Minterm D = Ab
	moveq.l	#%00000001,d7		; Mask
	CALLLIB	_LVOBltBitMap		; Do the blit
	movem.w	(sp)+,d5-d7
	addq.w	#4,d7
	bra.b	.do_nxt

.skip00	lsr.b	#1,d5
	addq.w	#4,d7
	bra.b	.skip01

.do_nxt	cmp.w	d7,d6
	bls.b	.exit
	cmp.b	#TRUE,txt_sameColor(a5)
	beq.b	.exit

	btst.l	#0,d5
	beq.b	.skip10

	movem.w	d0-d1/d5-d7,-(sp)
	movea.l	a2,a0			; SrcBM
	move.l	bm_Planes(a0,d7.w),bm_Planes(a0)
	movea.l	txt_maskBM(a5),a1	; DstBM
	moveq.l	#1,d0			; SrcX
	moveq.l	#1,d1			; SrcY
	move.w	tei_lineHeight(a3),d5	;
	add.w	txt_extraSpace(a5),d5	;
	add.w	ew_ySpacing(a4),d5	; SizeY
	move.w	#ANBC+NANBC,d6		; Minterm D = bC
	moveq.l	#%00000001,d7		; Mask
	CALLLIB	_LVOBltBitMap		; Do the blit
	movem.w	(sp)+,d0-d1/d5-d7

.skip10	lsr.b	#1,d5
	addq.w	#4,d7
	bra.b	.do_nxt

.exit	movea.l	txt_maskBM(a5),a1
	move.w	(sp)+,bm_BytesPerRow(a1)
	move.l	(sp)+,bm_Planes(a2)
	movem.w	(sp)+,d0-d7
	rts

.zero	movea.l	a2,a0			; SrcBM
	moveq.l	#1,d0			; SrcX
	moveq.l	#1,d1			; SrcY
	moveq.l	#0,d2			; DstX
	moveq.l	#0,d3			; DstY
	move.w	ew_Width(a4),d4		; SizeX
	move.w	tei_lineHeight(a3),d5	;
	add.w	txt_extraSpace(a5),d5	;
	add.w	ew_ySpacing(a4),d5	; SizeY
	move.w	#$30,d6			; Minterm D = Ab
	moveq.l	#%00000001,d7		; Mask
	CALLLIB	_LVOBltBitMap
	bra.b	.exit





; UWORD (d1) = teWhichCursorLine( (APTR) TEInfo (a3), Position (d2) )
; returns the linestart offset from actual line with char "position"
; a0 is set to linestart table, thus (a0,d1.w) points to 1st char of line

teWhichCursorLine

	movem.l	d0/d2/a1,-(sp)
	lea.l	tei_lineStarts(a3),a0
	moveq.l	#0,d1

	move.w	0(a0),d0
	cmp.w	2(a0),d0
	beq.b	.exit

.skip01	move.w	2(a0,d1.w),d0
	cmp.w	d2,d0
	bhi.b	.exit
	beq.b	.tstend
.skip02	addq.w	#2,d1
	bra.b	.skip01

.exit	movem.l	(sp)+,d0/d2/a1
	rts


.tstend	movea.l	tei_text(a3),a1
	lsl.w	#tec_SHIFTSIZE,d0
	tst.b	tec_charCode(a1,d0.w)
	bne.b	.skip02
	cmp.b	#LF,tec_charCode-tec_SIZE(a1,d0.w)
	bne.b	.exit
	addq.w	#2,d1
	bra.b	.exit





; UWORD (d3) = teCalcFitChars( (APTR) TEInfo (a3), Position (d2), Space (d3) )
;			(APTR) RastPort (a2) (APTR) EditWindow (a4)
; calculates amount of chars fitting in 'space' pixels, start at 'position'.

teCalcFitChars
	movem.l	d0-d2/d4-d6/a0-a1,-(sp)

	moveq.l	#-1,d4				; last space found

	movea.l	tei_text(a3),a0
	move.w	tei_textLength(a3),d5
	lsl.w	#tec_SHIFTSIZE,d2		; character position
	lsl.w	#tec_SHIFTSIZE,d5		; limiter

	moveq.l	#0,d0

.loop00	cmp.w	d2,d5
	beq.b	.exit

	move.b	tec_charCode(a0,d2.w),d6
	beq.b	.exit
	cmp.b	#' ',d6
	bne.b	.skip01
	move.w	d0,d4
.skip01	cmp.b	#LF,d6			; Linefeed ?
	beq.b	.exitlf
	lea.l	(a0,d2.w),a1

	bsr.w	teCharWidth

	cmp.w	d1,d3
	bls.b	.tstspc
	sub.w	d1,d3
	cmp.w	ew_xSpacing(a4),d3
	ble.b	.tstspc
	sub.w	ew_xSpacing(a4),d3
	addq.w	#tec_SIZE,d2
	addq.w	#1,d0
	bra.b	.loop00

.tstspc	cmp.w	#-1,d4			; is there a space found ?
	beq.b	.exit			; if not, we just truncate the word

	move.w	d4,d0			; last character is space
	addq.w	#1,d0

.exit	move.w	d0,d3
	movem.l	(sp)+,d0-d2/d4-d6/a0-a1
	rts

.exitlf	addq.w	#1,d0
	bra.b	.exit





; UWORD (d0) = teExtraSpace( (APTR) EditWindow (a4) )
; calculates if extra vertical space is needed for the lines. (shadow)

teExtraSpace

	movem.l	d1/d2/a0,-(sp)

	moveq.l	#0,d0

	cmpi.b	#SHADOWTYPE_NORMAL,ew_shadowType(a4)
	beq.b	.exit

	cmpi.b	#SHADOWTYPE_CAST,ew_shadowType(a4)
	beq.b	.shdw01
	cmpi.b	#SHADOWTYPE_SOLID,ew_shadowType(a4)
	beq.b	.shdw01

	cmpi.b	#SHADOWTYPE_OUTLINE,ew_shadowType(a4)
	beq.b	.shdw00
	cmpi.b	#SHADOWTYPE_TRANSPARENT,ew_shadowType(a4)
	beq.b	.shdw00
	bra.b	.exit

.shdw00	addq.w	#2,d0
	bra.b	.exit

.shdw01	moveq.l	#1,d2
	moveq.l	#0,d1
	lea.l	teDirectionTable(pc),a0
	move.b	ew_shadowDirection(a4),d1
	add.b	ew_shadowDepth(a4),d2
	lsl.w	#2,d1
	tst.w	2(a0,d1.w)		; only horizontal ?
	beq.b	.exit			; if so, no extra space needed

	add.w	d2,d0

.exit	movem.l	(sp)+,d1/d2/a0
	rts





; UWORD (d3) = teCalcLineWidth( (APTR) TEInfo (a3), Position (d2) )
;		(APTR) RastPort (a2) (APTR) EditWindow (a4)
; calculates width of line containing character indicated by position.

teCalcLineWidth
	movem.l	d0-d2/d4-d5/a0-a1,-(sp)

	moveq.l	#0,d4				; all spaces (hehe)
	moveq.l	#0,d5				; last space offset

	bsr.w	teWhichCursorLine

	move.w	0(a0,d1.w),d0
	move.w	2(a0,d1.w),d2
	movea.l	tei_text(a3),a0
	moveq.l	#0,d3				; total size still zero
	lsl.w	#tec_SHIFTSIZE,d0
	lsl.w	#tec_SHIFTSIZE,d2

.skip04	cmp.w	d0,d2
	bls.b	.skip09
	lea.l	(a0,d0.w),a1
	cmpi.b	#32,tec_charCode(a1)
	sls.b	d4
	bhi.b	.skip05
	move.w	d3,d5				; new offset (width)
.skip05	bsr.w	teCharWidth
	add.w	d1,d3
	add.w	#tec_SIZE,d0
	cmp.w	d0,d2
	beq.b	.skip09
	add.w	ew_xSpacing(a4),d3
	bra.b	.skip04

.skip09	tst.b	d4
	beq.b	.skip10
	move.w	d5,d3
.skip10	movem.l	(sp)+,d0-d2/d4-d5/a0-a1
	rts






; UWORD (d3) = teWidthUpToCaret( (APTR) TEInfo (a3), Position (d2) )
;				APTR EditWindow A4,
; calculates width of line from start to character indicated by position.

teWidthUpToCaret
	movem.l	d0-d2/d4-d5/a0-a1,-(sp)

	bsr.w	teWhichCursorLine

	move.w	(a0,d1.w),d0
	moveq.l	#0,d3				; total size still zero
	movea.l	tei_text(a3),a0
	lsl.w	#tec_SHIFTSIZE,d0
	lsl.w	#tec_SHIFTSIZE,d2

.skip04	cmp.w	d0,d2
	bls.b	.skip09
	lea.l	(a0,d0.w),a1

	bsr.w	teCharWidth

	add.w	d1,d3
	add.w	#tec_SIZE,d0
	cmp.w	d0,d2
	beq.b	.skip09
	add.w	ew_xSpacing(a4),d3
	bra.b	.skip04

.skip09	movem.l	(sp)+,d0-d2/d4-d5/a0-a1
	rts



; UWORD _TELineHeight( TEInfo, EditWindow )

tel_TEInfo		equ	8
tel_EditWindow		equ	12

_TELineHeight

	link	a5,#0
	movem.l	d1/a0-a1/a4/a6,-(sp)

	movea.l	tel_TEInfo(a5),a3
	movea.l	tel_EditWindow(a5),a4

	move.w	tei_lineHeight(a3),d3
	bsr.w	teExtraSpace
	add.w	d0,d3
	add.w	ew_ySpacing(a4),d3

	move.w	d3,d0

	movem.l	(sp)+,d1/a0-a1/a4/a6
	unlk	a5
	rts


; UWORD (d3) = teCalcLineHeight( (APTR) TEInfo (a3), from (d2) to (d3) )
; calculates height of line containing the character indicated by position.

teCalcLineHeight
	movem.l	d0-d2/d4/a0-a2,-(sp)

	move.w	d2,d0
	move.w	d2,d4
	move.w	d3,d1

	movea.l	tei_text(a3),a0
	moveq.l	#0,d3				; total height still zero

	lsl.w	#tec_SHIFTSIZE,d0
	lsl.w	#tec_SHIFTSIZE,d1

	cmpi.b	#LF,tec_charCode(a0,d0.w)
	bne.b	.skip00

	movea.l	tec_charFont(a0,d0.w),a2
	move.w	tf_YSize(a2),d3
	move.w	d3,tei_lineHeight(a3)
	move.w	tf_Baseline(a2),tei_baseLine(a3)
	bra.b	.exit2

.skip00	movem.w	d0/d1/d4,-(sp)
.testup	cmp.w	d0,d1
	bls.b	.endup

	tst.b	tec_charCode(a0,d0.w)
	beq.b	.endup

	cmpi.b	#31,tec_charCode(a0,d0.w)
	bls.b	.nextup

;	cmp.w	ew_LastChar(a4),d4
;	bge.w	.nextup

	movea.l	tec_charFont(a0,d0.w),a2
	move.w	tf_Baseline(a2),d2
	cmp.w	d3,d2
	bls.b	.nextup
	move.w	d2,d3
.nextup	addq.w	#1,d4
	add.w	#tec_SIZE,d0
	bra.b	.testup
.endup	movem.w	(sp)+,d0/d1/d4

	move.w	d3,tei_baseLine(a3)
	moveq.l	#0,d3

.testlo	cmp.w	d0,d1
	bls.b	.exit

	tst.b	tec_charCode(a0,d0.w)
	beq.b	.exit

	cmpi.b	#31,tec_charCode(a0,d0.w)
	bls.b	.nextlo

;	cmp.w	ew_LastChar(a4),d4
;	bge.w	.nextlo

	movea.l	tec_charFont(a0,d0.w),a2
	move.w	tf_YSize(a2),d2
	sub.w	tf_Baseline(a2),d2
	cmp.w	d3,d2
	bls.b	.nextlo
	move.w	d2,d3
.nextlo	addq.w	#1,d4
	add.w	#tec_SIZE,d0
	bra.b	.testlo

.exit	add.w	tei_baseLine(a3),d3
	beq.b	.empty				; if no printable scan backw.
	move.w	d3,tei_lineHeight(a3)
.exit2	bsr.w	teExtraSpace
	add.w	d0,d3
.exit3	movem.l	(sp)+,d0-d2/d4/a0-a2
	rts


.caret	movea.l	tei_newText+tec_charFont(a3),a2
	move.w	tf_YSize(a2),d3
	move.w	d3,tei_lineHeight(a3)
	move.w	tf_Baseline(a2),tei_baseLine(a3)
	bra.b	.exit2

.empty	tst.w	d0
	beq.b	.caret
	move.w	d0,d1
.emp01	subq.w	#tec_SIZE,d0
	beq.b	.chklf
	cmpi.b	#31,tec_charCode(a0,d0.w)
	bls.b	.emp01

;	cmp.w	ew_LastChar(a4),d4
;	bge.w	.emp01

	movea.l	tec_charFont(a0,d0.w),a2
	move.w	tf_YSize(a2),d3
	move.w	d3,tei_lineHeight(a3)
	move.w	tf_Baseline(a2),tei_baseLine(a3)
	bra.b	.exit2

.chklf	subq.w	#tec_SIZE,d1
	beq.b	.caret
	cmpi.b	#LF,tec_charCode(a0,d1.w)
	bne.b	.chklf
;	cmp.w	ew_LastChar(a4),d4
;	bge.w	.chklf
	movea.l	tec_charFont(a0,d1.w),a2
	move.w	tf_YSize(a2),d3
	move.w	d3,tei_lineHeight(a3)
	move.w	tf_Baseline(a2),tei_baseLine(a3)
	bra.b	.exit2




; VOID teRecalLines( (APTR) TEInfo (a3) )
; linestarts and endings are recalculated

teRecalLines
	movem.l	d0-d5/a4-a5,-(sp)

	lea.l	tei_lineStarts(a3),a5

	cmp.b	#RECALC_NONE,tei_recalLines(a3)
	beq.w	.exit3		; do NOTHING if no updating needed
	cmp.b	#RECALC_FAST,tei_recalLines(a3)
	beq.w	.exit3		; do NOTHING when not needed to do anything.

	clr.w	0(a5)

	TSTNODE	a3,a4
	beq.w	.exit

	clr.w	ew_FirstChar(a4)
	move.w	#1,ew_LastChar(a4)

	moveq.l	#0,d2		; counter

	move.w	ew_Height(a4),d1
	sub.w	ew_TopMargin(a4),d1
	sub.w	ew_BottomMargin(a4),d1
	bmi.w	.nxtwdw

.ctloop	cmp.w	(a5),d2		; is new value other than old one ?
	beq.b	.nochg		; same. no update needed

	cmp.b	#RECALC_DONE,tei_recalLines(a3)
	beq.b	.nochg		; override when done for line

	cmp.b	#RECALC_LINE,tei_recalLines(a3)
	bne.b	.nospec

	move.w	d2,d3
	sub.w	(a5),d3
	cmp.w	#1,d3
	beq.b	.spec
	cmp.w	#-1,d3
	beq.b	.spec
	move.b	#RECALC_FULL,tei_recalLines(a3)	
	bra.b	.nospec

.spec	movem.w	d0-d1,-(sp)
	move.w	-2(a5),d0
	move.w	d0,d1
	bsr.w	teSetUpdateRange
	movem.w	(sp)+,d0-d1
	move.b	#RECALC_DONE,tei_recalLines(a3)
	bra.b	.nochg

.nospec	move.w	d1,-(sp)
	move.w	d2,d0
	move.w	d2,d1
	subq.w	#1,d0
	bsr.w	teSetUpdateRange
	move.w	(sp)+,d1

.nochg	move.w	d2,(a5)		; set linestart for current line

	cmp.w	tei_textLength(a3),d2
	bge.b	.exit

	move.w	ew_Width(a4),d3
	sub.w	ew_LeftMargin(a4),d3
	sub.w	ew_RightMargin(a4),d3
	bmi.w	.nxtwdw

	bsr.w	teCalcFitChars
;	cmp.w	tei_textLength(a3),d2
;	bge.b	.exit
	move.w	d3,d4

	add.w	d2,d3
	bsr.w	teCalcLineHeight

	cmp.w	d1,d3
	bhi.b	.nxtwdw
; PATCHED: incorrect determination of end of window
;	bhi.b	.endwdw

	add.w	ew_ySpacing(a4),d3
	sub.w	d3,d1

	addq.w	#2,a5		; update linestart pointer
	add.w	d4,d2		; increase counter with chars on this line

	bra.w	.ctloop

.exit	tst.l	(a4)		; test if invalid pointer
	beq.b	.exit2		; if so, then no update of these parms
	move.w	d2,ew_LastChar(a4)
.exit2	move.w	0(a5),2(a5)		; make sure we set end of table

.exit3	movem.l	(sp)+,d0-d5/a4-a5
	move.b	#RECALC_NONE,tei_recalLines(a3) ; we've just calculated them
;	tst.b	tei_fastUpdate(a3)
;	beq.b	.exit3a
;	move.b	#RECALC_FAST,tei_recalLines(a3)
.exit3a	rts


.nxtwdw	move.w	d2,ew_LastChar(a4)
	TSTNODE	a4,a4
	beq.b	.exit
	move.w	d2,ew_FirstChar(a4)
	move.w	ew_Height(a4),d1
	sub.w	ew_TopMargin(a4),d1
	sub.w	ew_BottomMargin(a4),d1
	bmi.b	.nxtwdw
	bra.w	.ctloop

.endwdw	add.w	d4,d2
	move.w	d2,ew_LastChar(a4)
	bra.b	.exit


;-------------------------------------------------------------------------
; func: VOID TESetUpdateRange( struct EditWindow *, UWORD level )
;-------------------------------------------------------------------------
; Set range to be updated
;-------------------------------------------------------------------------

_TESetUpdateRange

.EditWindow	equ	8
.level		equ	14

	link	a5,#0
	movem.l	d0-d1/a3-a4,-(sp)

	movea.l	.EditWindow(a5),a4
	movea.l	ew_teInfo(a4),a3

	cmp.w	#LEVEL_FULL,.level(a5)
	beq.b	.full
	cmp.w	#LEVEL_WINDOW,.level(a5)
	beq.b	.window

.range	move.w	tei_selStart(a3),d0
	move.w	tei_selEnd(a3),d1
	cmp.w	d0,d1
	beq.b	.exit
	bra.b	.update

.window	move.w	ew_FirstChar(a4),d0
	move.w	ew_LastChar(a4),d1
;	bsr.w	teSetUpdateRange
	bra.b	.update

.full	move.w	ew_FirstChar(a4),d0
	move.w	tei_textLength(a3),d1

.update	bsr.b	teSetUpdateRange

.exit	movem.l	(sp)+,d0-d1/a3-a4
	unlk	a5
	rts





; VOID teSetUpdateRange( TEInfo (a3), start (d0.w), end (d1.w) )
; expands limits (if needed) of begin and end to update

teSetUpdateRange
	addq.w	#1,d1
	cmp.w	tei_firstChanged(a3),d0
	bhi.b	.nochg1
	move.w	d0,tei_firstChanged(a3)
.nochg1	cmp.w	tei_lastChanged(a3),d1
	bls.b	.nochg2
	move.w	d1,tei_lastChanged(a3)
.nochg2	move.b	#RECALC_FULL,tei_recalLines(a3)	; make sure it's updated
	subq.w	#1,d1
	rts




; UWORD (d1) = teCharWidth( struct TEChar * (a1) )
; calculates width of specified character

teCharWidth
	movem.l	d3-d6/a0/a2,-(sp)
	moveq.l	#0,d1
	cmp.b	#31,tec_charCode(a1)
	bls.b	.exit
	movea.l	tec_charFont(a1),a2
	btst.b	#FPB_PROPORTIONAL,tf_Flags(a2)
	beq.b	.nomnal

.propor	moveq.l	#0,d3
	move.b	tec_charCode(a1),d3
	move.b	tf_LoChar(a2),d4
	move.b	tf_HiChar(a2),d5
	cmp.b	d3,d4			; if LoChar > char
	bhi.b	.otble1
	cmp.b	d5,d3			; if char > HiChar
	bhi.b	.otble1
.itble1	sub.b	d4,d3			; char -= LoChar
	bra.b	.ofsdne
.otble1	sub.b	d4,d5
	addq.b	#1,d5
	move.b	d5,d3

.ofsdne	lsl.w	#1,d3
	movea.l	tf_CharKern(a2),a0
	cmpa.w	#0,a0
	beq.b	.skip00
	add.w	(a0,d3.w),d1		; increase horizontal destx
.skip00	movea.l	tf_CharSpace(a2),a0
	cmpa.w	#0,a0
	bne.b	.skip01
	add.w	tf_XSize(a2),d1
	bra.b	.tstbld
.skip01	add.w	(a0,d3.w),d1

.tstbld	btst.b	#MFSB_BOLD,tec_charStyle+1(a1)
	beq.b	.exit
	btst.b	#FSB_BOLD,tf_Style(a2)
	bne.b	.exit
	add.w	tf_BoldSmear(a2),d1
	bra.b	.exit

.nomnal	add.w	tf_XSize(a2),d1

.exit	movem.l	(sp)+,d3-d6/a0/a2
	rts


;-------------------------------------------------------------------------
; func: void _TEKey( struct TEInfo *, UWORD charCode )
;-------------------------------------------------------------------------
; Inserts characters & deletes characters backspaced over / deleted
;-------------------------------------------------------------------------

_TEKey

.TEInfo		equ	8
.charCode	equ	14

	link	a5,#0
	movem.l	d0-d1/a0-a1/a3,-(sp)

	movea.l	.TEInfo(a5),a3
	movea.l	_GfxBase,a6

	cmp.b	#FALSE,tei_caretState(a3)
	beq.b	.cont

	move.b	#FALSE,tei_caretState(a3)
	movem.l	d0-d7/a0-a6,-(sp)
	bsr.w	teReverseCaret
	movem.l	(sp)+,d0-d7/a0-a6

.cont	move.w	.charCode(a5),d0
	cmp.b	#DEL,d0
	beq.w	.erase
	cmp.b	#BS,d0
	beq.w	.erase
	cmp.b	#CR,d0
	bne.b	.ctrl

	move.w	tei_selStart(a3),d0
	move.w	tei_selEnd(a3),d1
	bsr.w	teSetUpdateRange

	bsr.w	teDelSelection
	movea.l	tei_text(a3),a1
	move.w	tei_selStart(a3),d0
	lsl.w	#tec_SHIFTSIZE,d0
	cmp.b	#' ',tec_charCode(a1,d0.w)
	bne.b	.other
	addi.w	#1,tei_selStart(a3)
	bra.b	.spc2lf
.other	subq.w	#tec_SIZE,d0
	cmp.b	#' ',tec_charCode(a1,d0.w)
	beq.b	.spc2lf
	move.b	#LF,d0
	bra.b	.doit

.spc2lf	move.l	tei_newText+tec_charFont(a3),tec_charFont(a1,d0.w)
	move.w	tei_newText+tec_charStyle(a3),tec_charStyle(a1,d0.w)
	move.b	tei_newText+tec_charColor(a3),tec_charColor(a1,d0.w)
	move.b	#LF,tec_charCode(a1,d0.w)
	move.w	tei_selStart(a3),tei_selEnd(a3)
	bra.w	.update

.ctrl	cmp.b	#31,d0
	bls.w	.exit
;--------------------------------------------
.doit	move.w	tei_selStart(a3),d1
	cmp.w	tei_selEnd(a3),d1
	beq.w	.caret

	bsr.w	teDelSelection
	bsr.w	teInsertChar
	bra.w	.update

.caret	movem.l	d2-d4/a0,-(sp)
	move.w 	tei_selStart(a3),d2
	bsr.w	teWhichCursorLine
	move.w	0(a0,d1.w),d2
	move.w	2(a0,d1.w),d3
	movem.w	d2/d3,-(sp)
	bsr.w	teCalcLineHeight	; set d3 to height
	bsr.w	teInsertChar
	move.w	d3,d0
	movem.w	(sp)+,d2/d3
	addq.w	#1,d3
	bsr.w	teCalcLineHeight
	cmp.w	d3,d0
	movem.l	(sp)+,d2-d4/a0
	bne.w	.update

	move.w	tei_selStart(a3),d0
	move.w	tei_selEnd(a3),d1
	bsr.w	teSetUpdateRange
	move.b	#RECALC_LINE,tei_recalLines(a3)
	bra.w	.exit
;--------------------------------------------
.erase	move.w	tei_selStart(a3),d1
	cmp.w	tei_selEnd(a3),d1
	beq.b	.nosel
	bsr.w	teDelSelection
	bra.b	.update
.nosel	cmp.b	#BS,d0
	bne.b	.noBS
.yesBS	tst.w	tei_selStart(a3)
	beq.b	.exit
	subi.w	#1,tei_selStart(a3)
	move.w	tei_selStart(a3),tei_selEnd(a3)

.noBS	movem.l	d2-d4/a0,-(sp)
	move.w 	tei_selStart(a3),d2
	bsr.w	teWhichCursorLine
	move.w	0(a0,d1.w),d2
	move.w	2(a0,d1.w),d3
	movem.w	d2/d3,-(sp)
	bsr.w	teCalcLineHeight	; set d3 to height
	bsr.w	teDelCharacter
	move.w	d3,d0
	movem.w	(sp)+,d2/d3
	addq.w	#1,d3
	bsr.w	teCalcLineHeight
	cmp.w	d3,d0
	movem.l	(sp)+,d2-d4/a0
	bne.b	.update
	move.w	tei_selStart(a3),d0
	move.w	tei_selEnd(a3),d1
	bsr.w	teSetUpdateRange
	move.b	#RECALC_LINE,tei_recalLines(a3)
	bra.b	.exit
;--------------------------------------------
.update	move.w	tei_selStart(a3),d0
	move.w	tei_selEnd(a3),d1
	bsr.w	teSetUpdateRange
	move.b	#RECALC_FULL,tei_recalLines(a3)
.exit	movem.l	(sp)+,d0-d1/a0-a1/a3
	unlk	a5
	rts


; VOID teInsertChar( TEInfo (a3), charCode (d0.b) )
; inserts character into the buffer, no error returned when full

teInsertChar
	movem.l	d0-d3/a0-a1,-(sp)
	move.w	tei_textLength(a3),d3
	cmpi.w	#TEXTEDITSIZE-2,d3
	bhi.b	.exit

	move.w	d3,d1				; start at end of text
	lsl.w	#tec_SHIFTSIZE,d1		; make it real offset
	sub.w	tei_selStart(a3),d3
	addq.w	#1,d3

	movea.l	tei_text(a3),a0
	lea.l	tec_SIZE(a0,d1.w),a0		; source
	lea.l	tec_SIZE(a0),a1			; destination

.dellp	move.l	-(a0),-(a1)
	move.l	-(a0),-(a1)
	dbra	d3,.dellp

.place	move.l	tei_newText+tec_charFont(a3),tec_charFont(a1)
	move.w	tei_newText+tec_charStyle(a3),tec_charStyle(a1)
	move.b	tei_newText+tec_charColor(a3),tec_charColor(a1)
	move.b	d0,tec_charCode(a1)

	addi.w	#1,tei_textLength(a3)
	addi.w	#1,tei_selStart(a3)
	move.w	tei_selStart(a3),tei_selEnd(a3)

.exit	movem.l	(sp)+,d0-d3/a0-a1
	rts


; VOID teDelSelection( TEInfo (a3) )
; removes selected range from the text

teDelSelection
	movem.l	d0-d2/a0-a1,-(sp)
	move.w	tei_selStart(a3),d0
	move.w	tei_selEnd(a3),d1
	cmp.w	d0,d1
	beq.b	.exit
	bsr.w	teSetUpdateRange

	move.w	tei_textLength(a3),d2
	sub.w	d1,d2				; copylength
	lsl.w	#tec_SHIFTSIZE,d0
	lsl.w	#tec_SHIFTSIZE,d1

	movea.l	tei_text(a3),a0
	movea.l	a0,a1
	add.w	d1,a0				; source
	add.w	d0,a1				; destination
.dellp	move.l	(a0)+,(a1)+
	move.l	(a0)+,(a1)+
	dbra	d2,.dellp
	move.w	tei_selEnd(a3),d0
	sub.w	tei_selStart(a3),d0
	sub.w	d0,tei_textLength(a3)
	move.w	tei_selStart(a3),tei_selEnd(a3)
.exit	movem.l	(sp)+,d0-d2/a0-a1
	rts



; VOID teDelCharacter( TEInfo (a3) )
; removes character indicated by the caret from the text

teDelCharacter
	movem.l	d0-d1/a0-a1,-(sp)
	move.w	tei_selStart(a3),d0
	move.w	tei_textLength(a3),d1
	sub.w	d0,d1
	beq.b	.exit

	movea.l	tei_text(a3),a1
	lsl.w	#tec_SHIFTSIZE,d0
	lea.l	(a1,d0.w),a1			; destination
	lea.l	tec_SIZE(a1),a0			; source

.dellp	move.l	(a0)+,(a1)+
	move.l	(a0)+,(a1)+
	dbra	d1,.dellp

	sub.w	#1,tei_textLength(a3)

.exit	movem.l	(sp)+,d0-d1/a0-a1
	rts


;-------------------------------------------------------------------------
; func: void _TEInitInfo( struct TEInfo * )
;-------------------------------------------------------------------------
; Initial TEInfo initialization
;-------------------------------------------------------------------------

_TEInitInfo

.TEInfo		equ	8

	link	a5,#0
	movem.l	d0/a3,-(sp)

	movea.l	.TEInfo(a5),a3

	move.l	#tei_SIZE-1,d0
.clrlp	clr.b	(a3,d0.w)
	dbra	d0,.clrlp

	move.b	#FALSE,tei_caretState(a3)
	move.b	#RECALC_FULL,tei_recalLines(a3)

	move.w	#0,tei_selStart(a3)
	move.w	#0,tei_selEnd(a3)

	move.w	#TEXTEDITSIZE,tei_lastChanged(a3)

.exit	movem.l	(sp)+,d0/a3
	unlk	a5
	rts




;-------------------------------------------------------------------------
; func: void _TEInitWindow( struct EditWindow *, struct RastPort * )
;-------------------------------------------------------------------------
; Initial EditWindow->TextInfo partial initialization
;-------------------------------------------------------------------------

_TEInitWindow

.EditWindow	equ	8
.RastPort	equ	12

	link	a5,#0
	movem.l	d0/a4,-(sp)

	movea.l	.EditWindow(a5),a4

	move.w	#0,ew_FirstChar(a4)
	move.w	#0,ew_LastChar(a4)

	move.b	#JUSTIFICATION_LEFT,ew_justification(a4)
	move.b	#ANTIALIAS_NONE,ew_antiAliasLevel(a4)
	move.b	#SHADOWTYPE_NORMAL,ew_shadowType(a4)
	move.b	#LIGHTSOURCE_SE,ew_shadowDirection(a4)
	move.b	#0,ew_shadowDepth(a4)
	move.b	#1,ew_shadowPen(a4)

	move.w	#2,ew_slantAmount(a4)
	move.w	#1,ew_slantValue(a4)
	clr.w	ew_xSpacing(a4)
	clr.w	ew_ySpacing(a4)
	move.w	#1,ew_underLineHeight(a4)
	move.w	#0,ew_underLineOffset(a4)

	move.l	.RastPort(a5),ew_rastPort(a4)

.exit	movem.l	(sp)+,d0/a4
	unlk	a5
	rts




;-------------------------------------------------------------------------
; func: void _TERemoveScrap( void )
;-------------------------------------------------------------------------
; Remove scrap buffer from memory
;-------------------------------------------------------------------------

_TERemoveScrap
	movem.l	d0-d1/a0-a1,-(sp)

	tst.l	_undoBuffer
	beq.b	.exit1
	move.l	_undoBuffer,a1
	move.l	-(a1),d0		; contains selStart/selEnd
	move.l	-(a1),d0		; contains textlength
	move.l	-(a1),d0		; contains allocsize-12
	addi.l	#12,d0
	LINKLIB	_LVOFreeMem,_SysBase
	clr.l	_undoBuffer


.exit1	tst.l	_scrapBuffer
	beq.b	.exit2
	move.l	_scrapBuffer,a1
	move.l	-(a1),d0
	addq.l	#4,d0
	LINKLIB	_LVOFreeMem,_SysBase
	clr.l	_scrapBuffer

.exit2	movem.l	(sp)+,d0-d1/a0-a1
	rts




;-------------------------------------------------------------------------
; func: void _TECut( struct TEInfo * )
;-------------------------------------------------------------------------
; Moves selection range to scrap
;-------------------------------------------------------------------------

_TECut

.TEInfo		equ	8

	link	a5,#0
	movem.l	d0-d2/a0-a1/a3,-(sp)

	move.l	.TEInfo(a5),a3

	move.w	tei_selStart(a3),d0
	cmp.w	tei_selEnd(a3),d0
	beq.w	.exit

	tst.l	_scrapBuffer
	beq.b	.skip00

	move.l	_scrapBuffer,a1
	move.l	-(a1),d0
	addq.l	#4,d0
	LINKLIB	_LVOFreeMem,_SysBase

.skip00	move.w	tei_selEnd(a3),d0
	sub.w	tei_selStart(a3),d0
	lsl.w	#tec_SHIFTSIZE,d0
	ext.l	d0
	move.l	d0,d2
	addq.l	#4,d0
	moveq.l	#MEMF_ANY,d1
	LINKLIB	_LVOAllocMem,_SysBase
	movea.l	d0,a1
	clr.l	_scrapBuffer
	tst.l	d0
	beq.b	.skip01

	move.l	d2,(a1)+
	move.l	a1,_scrapBuffer

	movea.l	tei_text(a3),a0
	move.w	tei_selStart(a3),d0
	lsl.w	#tec_SHIFTSIZE,d0
	lea.l	(a0,d0.w),a0
	move.l	d2,d0
	LINKLIB	_LVOCopyMemQuick,_SysBase

.skip01	bsr.w	teDelSelection

.exit	movem.l	(sp)+,d0-d2/a0-a1/a3
	unlk	a5
	rts





;-------------------------------------------------------------------------
; func: void _TECreateUndo( struct TEInfo * )
;-------------------------------------------------------------------------
; Creates undo buffer, and copies text to it.
;-------------------------------------------------------------------------

_TECreateUndo

.TEInfo		equ	8

	link	a5,#0
	movem.l	d0-d2/a0-a1/a3,-(sp)

	move.l	.TEInfo(a5),a3

	tst.l	_undoBuffer
	beq.b	.skip00

	move.l	_undoBuffer,a1
	move.l	-(a1),d0
	move.l	-(a1),d0
	move.l	-(a1),d0
	addi.l	#12,d0
	LINKLIB	_LVOFreeMem,_SysBase
	clr.l	_undoBuffer

.skip00	move.w	tei_textLength(a3),d0
	addq.w	#1,d0
	lsl.w	#tec_SHIFTSIZE,d0
	ext.l	d0
	move.l	d0,d2
	addi.l	#12,d0
	moveq.l	#MEMF_ANY,d1
	LINKLIB	_LVOAllocMem,_SysBase
	movea.l	d0,a1
	tst.l	d0
	beq.b	.exit

	move.l	d2,(a1)+
	clr.w	(a1)+
	move.w	tei_textLength(a3),(a1)+
	move.w	tei_selStart(a3),(a1)+
	move.w	tei_selEnd(a3),(a1)+
	move.l	a1,_undoBuffer

	movea.l	tei_text(a3),a0
	move.l	d2,d0
	LINKLIB	_LVOCopyMemQuick,_SysBase

.exit	movem.l	(sp)+,d0-d2/a0-a1/a3
	unlk	a5
	rts






;-------------------------------------------------------------------------
; func: void _TEPerformUndo( struct TEInfo * )
;-------------------------------------------------------------------------
; Perfoms undo (if possible) thus restoring a destructive operation.
;-------------------------------------------------------------------------

_TEPerformUndo

.TEInfo		equ	8

	link	a5,#0
	movem.l	d0-d1/a0-a3,-(sp)

	tst.l	_undoBuffer
	beq.b	.exit

	movea.l	.TEInfo(a5),a3
	movea.l	_undoBuffer,a2
	movea.l	tei_text(a3),a1
	move.l	-12(a2),d0
	movea.l	a2,a0
	LINKLIB	_LVOCopyMemQuick,_SysBase

	move.w	-6(a2),tei_textLength(a3)
	move.w	-4(a2),tei_selStart(a3)
	move.w	-2(a2),tei_selEnd(a3)

	movea.l	a2,a1
	move.l	-(a1),d0
	move.l	-(a1),d0
	move.l	-(a1),d0
	addi.l	#12,d0
	LINKLIB	_LVOFreeMem,_SysBase
	clr.l	_undoBuffer

.exit	movem.l	(sp)+,d0-d1/a0-a3
	unlk	a5
	rts








;-------------------------------------------------------------------------
; func: void _TECopy( struct TEInfo * )
;-------------------------------------------------------------------------
; Copy characters to scrap
;-------------------------------------------------------------------------

_TECopy

.TEInfo		equ	8

	link	a5,#0
	movem.l	d0-d2/a0-a1/a3,-(sp)

	move.l	.TEInfo(a5),a3

	move.w	tei_selStart(a3),d0
	cmp.w	tei_selEnd(a3),d0
	beq.w	.exit

	tst.l	_scrapBuffer
	beq.b	.skip00

	move.l	_scrapBuffer,a1
	move.l	-(a1),d0
	addq.l	#4,d0
	LINKLIB	_LVOFreeMem,_SysBase

.skip00	move.w	tei_selEnd(a3),d0
	sub.w	tei_selStart(a3),d0
	lsl.w	#tec_SHIFTSIZE,d0
	ext.l	d0
	move.l	d0,d2
	addq.l	#4,d0
	moveq.l	#MEMF_ANY,d1
	LINKLIB	_LVOAllocMem,_SysBase
	movea.l	d0,a1
	clr.l	_scrapBuffer
	tst.l	d0
	beq.b	.exit

	move.l	d2,(a1)+
	move.l	a1,_scrapBuffer

	movea.l	tei_text(a3),a0
	move.w	tei_selStart(a3),d0
	lsl.w	#tec_SHIFTSIZE,d0
	lea.l	(a0,d0.w),a0
	move.l	d2,d0
	LINKLIB	_LVOCopyMemQuick,_SysBase

.exit	movem.l	(sp)+,d0-d2/a0-a1/a3
	unlk	a5
	rts





;-------------------------------------------------------------------------
; func: void _TEPaste( struct TEInfo * )
;-------------------------------------------------------------------------
; Inserts characters from the scrap to selStart (as far as possible)
;-------------------------------------------------------------------------

_TEPaste

.TEInfo		equ	8

	link	a5,#0
	movem.l	d0-d3/a0-a4,-(sp)

	move.l	.TEInfo(a5),a3
	bsr.w	teDelSelection

	tst.l	_scrapBuffer
	beq.b	.exit

	movea.l	_scrapBuffer,a4
	move.l	-4(a4),d0
	move.l	d0,d2
	lsr.w	#tec_SHIFTSIZE,d0

	movea.l	tei_text(a3),a0

	move.w	tei_textLength(a3),d3
	add.w	d0,d3
	cmpi.w	#TEXTEDITSIZE-3,d3
	bhi.b	.exit

	;bra.b	.exit
	;move.w	#TEXTEDITSIZE-3,d3
	;sub.w	d0,d3
	;move.w	d3,tei_textLength(a3)
	;lsl.w	#tec_SHIFTSIZE,d3
	;clr.b	tec_charCode(a0,d3.w)

.init	move.w	tei_textLength(a3),d3
	sub.w	tei_selStart(a3),d3		; size for dbra

	move.w	tei_textLength(a3),d1
	lsl.w	#tec_SHIFTSIZE,d1
	lea.l	tec_SIZE(a0,d1.w),a1		; source
	lea.l	(a1,d2.w),a2			; destination

.insert	move.l	-(a1),-(a2)
	move.l	-(a1),-(a2)
	dbra	d3,.insert

	movem.w	d0-d1,-(sp)
	move.w	tei_selStart(a3),d1
	add.w	d0,d1
	move.w	tei_selStart(a3),d0
	bsr.w	teSetUpdateRange
	movem.w	(sp)+,d0-d1

	move.w	tei_selStart(a3),d1
	lsl.w	#tec_SHIFTSIZE,d1

	add.w	d0,tei_selStart(a3)
	add.w	d0,tei_textLength(a3)
	move.w	tei_selStart(a3),tei_selEnd(a3)

	lea.l	(a0,d1.w),a1
	movea.l	a4,a0
	move.l	d2,d0
	LINKLIB	_LVOCopyMemQuick,_SysBase

.exit	movem.l	(sp)+,d0-d3/a0-a4
	unlk	a5
	rts





;-------------------------------------------------------------------------
; func: void _TEDelete( struct TEInfo * )
;-------------------------------------------------------------------------
; Removes characters indicated by selection range
;-------------------------------------------------------------------------

_TEDelete

.TEInfo		equ	8

	link	a5,#0
	movem.l	d0-d1/a0-a1/a3,-(sp)

	move.l	.TEInfo(a5),a3
	bsr.w	teDelSelection

.exit	movem.l	(sp)+,d0-d1/a0-a1/a3
	unlk	a5
	rts



;-------------------------------------------------------------------------
; func: void _TEActivate( struct TEInfo * )
;-------------------------------------------------------------------------
; Display caret or selection box (removes old one first)
;-------------------------------------------------------------------------

_TEActivate

.stckframesize	equ	-0

.TEInfo		equ	8

	link	a5,#.stckframesize
	movem.l	d0-d7/a0-a4/a6,-(sp)

	movea.l	.TEInfo(a5),a3
	movea.l	_GfxBase,a6

	cmp.b	#TRUE,tei_caretState(a3)
	beq.b	.exit

	move.b	#TRUE,tei_caretState(a3)
	bsr.w	teReverseCaret

.exit	movem.l	(sp)+,d0-d7/a0-a4/a6
	unlk	a5
	rts

;-------------------------------------------------------------------------
; func: void _TEDeactive( struct TEInfo * )
;-------------------------------------------------------------------------
; Removes (if any) drawn caret or selection range
;-------------------------------------------------------------------------

_TEDeactivate

.stckframesize	equ	-0

.TEInfo		equ	8

	link	a5,#.stckframesize
	movem.l	d0-d7/a0-a4/a6,-(sp)

	movea.l	.TEInfo(a5),a3
	movea.l	_GfxBase,a6

	cmp.b	#FALSE,tei_caretState(a3)
	beq.b	.exit

	move.b	#FALSE,tei_caretState(a3)
	bsr.w	teReverseCaret

.exit	movem.l	(sp)+,d0-d7/a0-a4/a6
	unlk	a5
	rts

;--------------------------------------------------------
calc_pos_n_height
;--------------------------------------------------------
	moveq.l	#-1,d3
	move.w	d2,-(sp)

	move.l	d2,-(sp)
	move.l	a3,-(sp)
	bsr.w	_TEWhichBox
	lea.l	8(sp),sp
	tst.l	d0
	beq.w	.exit
	movea.l	d0,a4
	
.go_on	movea.l	ew_rastPort(a4),a2
	movea.l	a2,a1
	move.l	#RP_COMPLEMENT,d0
	CALLLIB	_LVOSetDrMd

	move.w	d2,d4
	move.w	ew_FirstChar(a4),d2
	bsr.w	teWhichCursorLine
	adda.w	d1,a0
	move.w	ew_TopMargin(a4),d1	; initial y_offset
;-------------------------------------------------
	movem.l	d1/a0,-(sp)
	move.w	d4,d2
	bsr.w	teWhichCursorLine
	adda.w	d1,a0
	movea.l	a0,a1
	movem.l	(sp)+,d1/a0

.y_offs	move.w	0(a0),d2
	move.w	2(a0),d3

	bsr.w	teCalcLineHeight

	move.w	(a0),d2
	cmp.w	(a1),d2
	beq.b	.x_offs

	add.w	d3,d1
	add.w	ew_ySpacing(a4),d1
	adda.w	#2,a0
	bra.b	.y_offs
;-------------------------------------------------
.x_offs	move.w	d4,d2
	bsr.w	teWidthUpToCaret
	cmp.w	ew_LeftMargin(a4),d3
	beq.b	.tstjst
	add.w	ew_xSpacing(a4),d3

.tstjst	cmp.b	#JUSTIFICATION_LEFT,ew_justification(a4)
	bne.b	.dojust
	add.w	ew_LeftMargin(a4),d3
	bra.b	.exit

.dojust	movem.w	d2/d4,-(sp)
	move.w	d3,d4
	bsr.w	teCalcLineWidth
	move.w	ew_Width(a4),d2
	sub.w	ew_RightMargin(a4),d2
	cmp.b	#JUSTIFICATION_RIGHT,ew_justification(a4)
	beq.b	.justRI

.justCE	sub.w	ew_LeftMargin(a4),d2
	lsr.w	#1,d2
	add.w	ew_LeftMargin(a4),d2
	lsr.w	#1,d3
	sub.w	d3,d2
	add.w	d4,d2
	bra.b	.endjst

.justRI	sub.w	d3,d2
	add.w	d4,d2

.endjst	move.w	d2,d3
	movem.w	(sp)+,d2/d4

.exit	move.w	d3,d0
	move.w	(sp)+,d2
	rts
;--------------------------------------------------------





;--------------------------------------------------------
teReverseCaret
;--------------------------------------------------------
	moveq.l	#0,d2
	move.w	tei_selStart(a3),d2
	move.l	d2,-(sp)
	move.l	a3,-(sp)
	bsr.w	_TEWhichBox
	lea.l	8(sp),sp
	tst.l	d0
	beq.b	.exit
	movea.l	d0,a4
	movea.l	ew_rastPort(a4),a1
	cmp.w	tei_selEnd(a3),d2
	bne.w	.range

.caret	movem.l	d2-d4/a0-a4,-(sp)
	bsr.w	calc_pos_n_height
	movem.l	(sp)+,d2-d4/a0-a4
	tst.w	d0
	bmi.b	.exit
	tst.w	d1
	bmi.b	.exit

	move.w	ew_Width(a4),d4
	sub.w	ew_RightMargin(a4),d4
	cmp.w	d0,d4
	bhi.b	.skip0
	move.w	d4,d0
.skip0	add.w	ew_X(a4),d0
	add.w	ew_Y(a4),d1
	move.w	d0,d2
	addq.w	#2,d2
	move.w	d1,d3
	bsr.w	.GetHeight
	add.w	d5,d3
;	add.w	ew_ySpacing(a4),d3
	subq.w	#1,d3
	bsr.w	.RectFill

.exit	rts


;--------------------------------------------------------
; for ranges, we have 3 possible situations:
; - somewhere in the line to somewhere in the same line
; - somewhere in the line to somewhere on the next line
; - somewhere in the line to somewhere on another line
;   filled up with totally reversed lines.
; the last 2 situations can be linked together, filling
; up the intermediate lines by reversing the full block
; if start and end lines have space between them.
;--------------------------------------------------------
.range	movem.l	d2-d4/a0-a4,-(sp)
	bsr.w	calc_pos_n_height
	movem.l	(sp)+,d2-d4/a0-a4
	move.w	tei_lineHeight(a3),d5
	move.w	ew_Height(a4),d4
	sub.w	ew_TopMargin(a4),d4
	sub.w	ew_BottomMargin(a4),d4
	bsr.w	.GetHeight
	add.w	ew_ySpacing(a4),d5
	cmp.w	d4,d5
	bhi.w	.exit

	move.w	tei_lineHeight(a3),d5

	move.w	tei_selEnd(a3),d2
	bsr.w	.limit

	movem.w	d0-d1,-(sp)
	movem.l	d2-d4/a0-a4,-(sp)
	bsr.w	calc_pos_n_height
	movem.l	(sp)+,d2-d4/a0-a4
	tst.w	d0
	bmi.w	.exit
	beq.b	.cont
	subq.w	#1,d0
.cont	move.w	d0,d6
	move.w	d1,d7
	movem.w	(sp)+,d0-d1

	tst.w	d0
	bmi.b	.exit
	tst.w	d1
	bmi.b	.exit
	tst.w	d6
	bmi.b	.exit
	tst.w	d7
	bmi.b	.exit

	add.w	ew_X(a4),d0
	add.w	ew_Y(a4),d1
	add.w	ew_X(a4),d6
	add.w	ew_Y(a4),d7

.sit1	move.w	d6,d2
	move.w	d1,d3
	add.w	ew_ySpacing(a4),d3
	add.w	d5,d3
	subq.w	#1,d3
	move.w	ew_X(a4),d4
	add.w	ew_Width(a4),d4
	sub.w	ew_RightMargin(a4),d4
	subq.w	#1,d4
	cmp.w	d1,d7
	beq.b	.skip10
	move.w	d4,d2
.skip10	bsr.w	.RectFill
	cmp.w	d1,d7
	beq.w	.exit

.sit2	addq.w	#1,d3
	cmp.w	d3,d7
	beq.b	.sit3
	move.w	ew_X(a4),d0
	add.w	ew_LeftMargin(a4),d0
	move.w	d3,d1
	move.w	ew_X(a4),d2
	add.w	ew_Width(a4),d2
	sub.w	ew_RightMargin(a4),d2
	subq.w	#1,d2
	move.w	d7,d3
	subq.w	#1,d3
	bsr.w	.RectFillSpecial

.sit3	move.w	ew_X(a4),d0
	add.w	ew_LeftMargin(a4),d0
	move.w	d7,d1
	move.w	d6,d2
	move.w	d7,d3
	bsr.w	.GetHeight
	add.w	d5,d3
	add.w	ew_ySpacing(a4),d3
	subq.w	#1,d3
	bsr.w	.RectFillSpecial
	bra.w	.exit


.RectFill
	movem.l	d0-d4/a0-a1,-(sp)
	cmp.w	d2,d0
	bls.b	.skip90
	move.w	d0,d2
.skip90	cmp.w	d3,d1
	bls.b	.skip91
	move.w	d1,d3
.skip91	move.w	ew_Y(a4),d4
	add.w	ew_Height(a4),d4
	sub.w	ew_BottomMargin(a4),d4
	cmp.w	d3,d4
	bls.b	.skip92
	CALLLIB	_LVORectFill
.skip92	movem.l	(sp)+,d0-d4/a0-a1
	rts

.RectFillSpecial
	movem.l	d0-d4/a0-a1,-(sp)
	cmp.w	d2,d0
	bls.b	.skip93
	move.w	d0,d2
.skip93	cmp.w	d3,d1
	bls.b	.skip94
	move.w	d1,d3
.skip94	move.w	ew_Y(a4),d4
	add.w	ew_Height(a4),d4
	sub.w	ew_BottomMargin(a4),d4
	cmp.w	d3,d4
	bhi.b	.skip95
	move.w	d4,d3
	subq.w	#1,d3
.skip95	CALLLIB	_LVORectFill
	movem.l	(sp)+,d0-d4/a0-a1
	rts

.GetHeight
	move.w	tei_lineHeight(a3),d5
	move.w	d0,-(sp)
	bsr.w	teExtraSpace
	add.w	d0,d5
	move.w	(sp)+,d0
	rts

.limit	cmp.w	ew_LastChar(a4),d2
	blt.b	.estart
	move.w	ew_LastChar(a4),d2
	cmp.w	tei_textLength(a3),d2
	beq.b	.estart
	tst.w	d2
	beq.b	.estart
	subq.w	#1,d2
.estart	rts


;-------------------------------------------------------------------------
; func: VOID _TEReportPos( struct TEInfo *, UWORD *x, UWORD *y )
;-------------------------------------------------------------------------
; Report actual position of selStart
;-------------------------------------------------------------------------

_TEReportPos

.stck	equ	-0

.TEInfo	equ	8
.Xptr	equ	12
.Yptr	equ	16

	link	a5,#.stck
	movem.l	d0-d7/a0-a4/a6,-(sp)

	movea.l	.TEInfo(a5),a3
	movea.l	_GfxBase,a6

	movea.l	.Xptr(a5),a0
	movea.l	.Yptr(a5),a1
	move.w	#-1,(a0)
	move.w	#-1,(a1)

	move.w	tei_selStart(a3),d2
	move.l	d2,-(sp)
	move.l	a3,-(sp)
	bsr.w	_TEWhichBox
	lea.l	8(sp),sp
	tst.l	d0
	beq.b	.exit
	movea.l	d0,a4

	bsr.w	calc_pos_n_height
	movea.l	.Xptr(a5),a0
	movea.l	.Yptr(a5),a1
	move.w	d0,(a0)
	move.w	d1,(a1)
	tst.w	d0
	bmi.b	.exit

	move.w	tei_selStart(a3),d2
	movea.l	tei_text(a3),a2
	lsl.w	#tec_SHIFTSIZE,d2
	lea.l	(a2,d2.w),a1
	cmp.b	#31,tec_charCode(a1)
	bls.b	.exit
	bsr.w	teCharWidth
	lsr.w	#1,d1
	add.w	d1,(a0)

	cmp.w	#0,a4
	beq.b	.exit

	move.w	ew_Width(a4),d0
	sub.w	ew_RightMargin(a4),d0
	cmp.w	(a0),d0
	bhi.b	.exit
	move.w	d0,(a0)

.exit	movem.l	(sp)+,d0-d7/a0-a4/a6
	unlk	a5
	rts




;-------------------------------------------------------------------------
; func: UWORD _TEWhichLine( struct TEInfo * )
;-------------------------------------------------------------------------
; Report number of line cursor located on
;-------------------------------------------------------------------------

_TEWhichLine

.stckframesize	equ	-0

.TEInfo		equ	8

	link	a5,#.stckframesize
	movem.l	d1-d7/a0-a4/a6,-(sp)

	movea.l	.TEInfo(a5),a3

	move.w	tei_selStart(a3),d2
	bsr.w	teWhichCursorLine

	move.w	d1,d0
	lsr.w	#1,d0
	movem.l	(sp)+,d1-d7/a0-a4/a6
	unlk	a5
	rts




;-------------------------------------------------------------------------
; func: VOID TESetSelect( struct TEInfo *, UWORD selstart, UWORD selend )
;-------------------------------------------------------------------------
; Sets selection range or cursor position. No immediate display.
;-------------------------------------------------------------------------

_TESetSelect

.stckframesize	equ	-0

.TEInfo		equ	8
.selstart	equ	14
.selend		equ	18

	link	a5,#.stckframesize
	movem.l	d0-d4/a0-a4/a6,-(sp)

	movea.l	.TEInfo(a5),a3
	movea.l	_GfxBase,a6

	cmp.b	#FALSE,tei_caretState(a3)
	beq.b	.cont

	move.b	#FALSE,tei_caretState(a3)
	movem.l	d0-d7/a0-a6,-(sp)
	bsr.w	teReverseCaret
	movem.l	(sp)+,d0-d7/a0-a6

.cont	move.w	.selstart(a5),d0
	move.w	.selend(a5),d1
	cmp.w	d0,d1
	bhi.b	.limit
	exg.l	d0,d1

.limit	exg.l	d0,d1
	bsr.w	.limitA
	exg.l	d0,d1
	bsr.w	.limitA

	movem.l	d0/d1,-(sp)
	move.l	d0,-(sp)
	move.l	a3,-(sp)
	bsr.w	_TEWhichBox
	lea.l	8(sp),sp
	movea.l	d0,a4
	movem.l	(sp)+,d0/d1
	cmp.w	#0,a4
	beq.w	.moveEm

	tst.w	d0
	bne.b	.limit2
	cmp.w	tei_textLength(a3),d1
	bne.b	.limit2

.moveEm	move.w	d0,tei_selStart(a3)
	move.w	d1,tei_selEnd(a3)
	bra.b	.tstrng

.limit2	bsr.w	.limitB
	move.w	d0,tei_selStart(a3)
	move.w	d1,d0
	bsr.w	.limitB
	move.w	d0,tei_selEnd(a3)

.tstrng	move.w	tei_selStart(a3),d0
	cmp.w	tei_selEnd(a3),d0
	bne.w	.exit

	tst.w	tei_textLength(a3)
	beq.b	.exit

	move.w	d0,d2
	bsr.w	teWhichCursorLine
	move.w	(a0,d1.w),d2
	lsl.w	#tec_SHIFTSIZE,d2
	movea.l	tei_text(a3),a1
	cmpi.b	#LF,tec_charCode(a1,d2.w)
	bne.b	.skip01
	move.w	tec_charStyle(a1,d2.w),tei_newText+tec_charStyle(a3)
	move.b	tec_charColor(a1,d2.w),tei_newText+tec_charColor(a3)
	move.l	tec_charFont(a1,d2.w),tei_newText+tec_charFont(a3)
	bra.b	.exit

.skip01	lsl.w	#tec_SHIFTSIZE,d0
	cmp.w	d0,d2			; is cursor at start of line ?
	beq.b	.skip02
	move.w	d0,d1
	beq.b	.skip02
.emp01	subq.w	#tec_SIZE,d0
	bmi.b	.chklf
	cmpi.b	#31,tec_charCode(a1,d0.w)
	bls.b	.emp01
.skip02	tst.b	tec_charCode(a1,d0.w)
	bne.b	.skip03
	subq.w	#tec_SIZE,d0
.skip03	move.w	tec_charStyle(a1,d0.w),tei_newText+tec_charStyle(a3)
	move.b	tec_charColor(a1,d0.w),tei_newText+tec_charColor(a3)
	move.l	tec_charFont(a1,d0.w),tei_newText+tec_charFont(a3)
	bra.b	.exit

.chklf	subq.w	#tec_SIZE,d1
	bmi.b	.exit
	cmpi.b	#LF,tec_charCode(a1,d1.w)
	bne.b	.chklf

	move.w	tec_charStyle(a1,d0.w),tei_newText+tec_charStyle(a3)
	move.b	tec_charColor(a1,d0.w),tei_newText+tec_charColor(a3)
	move.l	tec_charFont(a1,d0.w),tei_newText+tec_charFont(a3)

.exit	movem.l	(sp)+,d0-d4/a0-a4/a6
	unlk	a5
	rts


.limitA	tst.w	d0
	bpl.b	.limA1
	moveq.l	#0,d0
.limA1	cmp.w	tei_textLength(a3),d0
	ble.b	.limA2
	move.w	tei_textLength(a3),d0
.limA2	rts


.limitB	cmp.w	ew_FirstChar(a4),d0
	bge.b	.bstart
	move.w	ew_FirstChar(a4),d0

.bstart	cmp.w	ew_LastChar(a4),d0
	blt.b	.estart

	move.w	ew_LastChar(a4),d0

	TSTNODE	a4,a1
	bne.b	.estart

	cmp.w	tei_textLength(a3),d0
	beq.b	.estart

	tst.w	d0
	beq.b	.estart

	subq.w	#1,d0

.estart	rts





;-------------------------------------------------------------------------
; func: VOID _TESetJustification( struct EditWindow *, UBYTE justmode )
;-------------------------------------------------------------------------
; Set justification mode for window
;-------------------------------------------------------------------------

_TESetJustification

.stckframesize	equ	-0

.EditWindow	equ	8
.justification	equ	15

	link	a5,#.stckframesize
	movem.l	d0-d1/a0-a1/a3-a4,-(sp)

	movea.l	.EditWindow(a5),a4
	cmpa.w	#0,a4
	beq.b	.exit
	movea.l	ew_teInfo(a4),a3
	move.w	ew_FirstChar(a4),d0
	move.w	ew_LastChar(a4),d1
	bsr.w	teSetUpdateRange
	move.b	.justification(a5),ew_justification(a4)

.exit	movem.l	(sp)+,d0-d1/a0-a1/a3-a4
	unlk	a5
	rts





;-------------------------------------------------------------------------
; func: VOID _TESetItalic( struct EditWindow *, UBYTE , UBYTE )
;-------------------------------------------------------------------------
; Set italic values for window
;-------------------------------------------------------------------------

_TESetItalic

.stckframesize	equ	-0

.EditWindow	equ	8
.slantAmount	equ	15
.slantValue	equ	19

	link	a5,#.stckframesize
	movem.l	d0-d1/a0-a1/a3-a4,-(sp)

	movea.l	.EditWindow(a5),a4
	cmpa.w	#0,a4
	beq.b	.exit
	movea.l	ew_teInfo(a4),a3
	move.w	ew_FirstChar(a4),d0
	move.w	ew_LastChar(a4),d1
	bsr.w	teSetUpdateRange
	moveq.l	#0,d0
	move.b	.slantAmount(a5),d0
	move.w	d0,ew_slantAmount(a4)
	move.b	.slantValue(a5),d0
	ext.w	d0
	move.w	d0,ew_slantValue(a4)

.exit	movem.l	(sp)+,d0-d1/a0-a1/a3-a4
	unlk	a5
	rts





;-------------------------------------------------------------------------
; func: VOID _TESetShadow( struct EditWindow *, UBYTE type, UBYTE depth,
;	UBYTE direction, UBYTE pen )
;-------------------------------------------------------------------------
; Set shadow mode for window
;-------------------------------------------------------------------------

_TESetShadow

.stckframesize	equ	-0

.EditWindow	equ	8
.shadowType	equ	15
.shadowDepth	equ	19
.shadowDir	equ	23
.shadowPen	equ	27

	link	a5,#.stckframesize
	movem.l	d0-d1/a0-a1/a3-a4,-(sp)

	movea.l	.EditWindow(a5),a4
	cmpa.w	#0,a4
	beq.b	.exit
	movea.l	ew_teInfo(a4),a3
	move.w	ew_FirstChar(a4),d0
	move.w	ew_LastChar(a4),d1
	bsr.w	teSetUpdateRange
	move.b	.shadowType(a5),ew_shadowType(a4)
	move.b	.shadowDepth(a5),ew_shadowDepth(a4)
	move.b	.shadowDir(a5),ew_shadowDirection(a4)
	move.b	.shadowPen(a5),ew_shadowPen(a4)

.exit	movem.l	(sp)+,d0-d1/a0-a1/a3-a4
	unlk	a5
	rts





;-------------------------------------------------------------------------
; func: VOID _TESetAntiAlias( struct EditWindow *, UBYTE level )
;-------------------------------------------------------------------------
; Set antialias mode for window
;-------------------------------------------------------------------------

_TESetAntiAlias

.stckframesize	equ	-0

.EditWindow	equ	8
.level		equ	15

	link	a5,#.stckframesize
	movem.l	d0-d1/a0-a1/a3-a4,-(sp)

	movea.l	.EditWindow(a5),a4
	cmpa.w	#0,a4
	beq.b	.exit
	movea.l	ew_teInfo(a4),a3
	move.w	ew_FirstChar(a4),d0
	move.w	ew_LastChar(a4),d1
	bsr.w	teSetUpdateRange
	move.b	.level(a5),ew_antiAliasLevel(a4)

.exit	movem.l	(sp)+,d0-d1/a0-a1/a3-a4
	unlk	a5
	rts





;-------------------------------------------------------------------------
; func: VOID _TESetFont( struct TEInfo *, struct TextFont * )
;-------------------------------------------------------------------------
; Set current font or font for selection range
;-------------------------------------------------------------------------

_TESetFont

.stckframesize	equ	-0

.TEInfo		equ	8
.TextFont	equ	12

	link	a5,#.stckframesize
	movem.l	d0-d2/a0-a1/a3,-(sp)

	move.l	.TEInfo(a5),a3

	move.l	.TextFont(a5),tei_newText+tec_charFont(a3)

	move.w	tei_selStart(a3),d0
	cmp.w	tei_selEnd(a3),d0
	beq.b	.exit

.selec	move.w	tei_selEnd(a3),d1
	movea.l	tei_text(a3),a0
	lsl.w	#tec_SHIFTSIZE,d0
	lsl.w	#tec_SHIFTSIZE,d1
	move.l	.TextFont(a5),d2
.loop01	cmp.w	d0,d1
	bls.b	.exit
	move.l	d2,tec_charFont(a0,d0.w)
	addq.w	#tec_SIZE,d0
	bra.b	.loop01

.exit	movem.l	(sp)+,d0-d2/a0-a1/a3
	unlk	a5
	rts





;-------------------------------------------------------------------------
; func: VOID _TESetStyle( struct TEInfo *, UWORD style, UWORD stylemask )
;-------------------------------------------------------------------------
; Set current style or style for selection range
;-------------------------------------------------------------------------

_TESetStyle

.stckframesize	equ	-0

.TEInfo		equ	8
.style		equ	14
.stylemask	equ	18

	link	a5,#.stckframesize
	movem.l	d0-d3/a0/a3,-(sp)

	move.l	.TEInfo(a5),a3

	move.w	.style(a5),d2
	move.w	.stylemask(a5),d3
	and.w	d3,d2
	not.w	d3

	and.w	d3,tei_newText+tec_charStyle(a3)
	or.w	d2,tei_newText+tec_charStyle(a3)

 	move.w	tei_selStart(a3),d0
	cmp.w	tei_selEnd(a3),d0
	beq.b	.exit

.selec	move.w	tei_selEnd(a3),d1
	movea.l	tei_text(a3),a0
	lsl.w	#tec_SHIFTSIZE,d0
	lsl.w	#tec_SHIFTSIZE,d1
.loop01	cmp.w	d0,d1
	bls.b	.exit
	and.w	d3,tec_charStyle(a0,d0.w)
	or.w	d2,tec_charStyle(a0,d0.w)
	addq.w	#tec_SIZE,d0
	bra.b	.loop01

.exit	movem.l	(sp)+,d0-d3/a0/a3
	unlk	a5
	rts




;-------------------------------------------------------------------------
; func: VOID _TESetColor( struct TEInfo *, UWORD color )
;-------------------------------------------------------------------------
; Set current color or color for selection range
;-------------------------------------------------------------------------

_TESetColor

.stckframesize	equ	-0

.TEInfo		equ	8
.color		equ	14

	link	a5,#.stckframesize
	movem.l	d0-d2/a0-a1/a3,-(sp)

	move.l	.TEInfo(a5),a3
	move.w	.color(a5),d2

	move.b	d2,tei_newText+tec_charColor(a3)

 	move.w	tei_selStart(a3),d0
	cmp.w	tei_selEnd(a3),d0
	beq.b	.exit

.selec	move.w	tei_selEnd(a3),d1
	movea.l	tei_text(a3),a0
	lsl.w	#tec_SHIFTSIZE,d0
	lsl.w	#tec_SHIFTSIZE,d1
.loop01	cmp.w	d0,d1
	bls.b	.exit
	move.b	d2,tec_charColor(a0,d0.w)
	addq.w	#tec_SIZE,d0
	bra.b	.loop01

.exit	movem.l	(sp)+,d0-d2/a0-a1/a3
	unlk	a5
	rts





;-------------------------------------------------------------------------
; func: struct EditWindow *_TEWhichBox( struct TEInfo *, UWORD position )
;-------------------------------------------------------------------------
; In which box is this character located ?
;-------------------------------------------------------------------------

_TEWhichBox

.stckframesize	equ	-0

.TEInfo		equ	8
.position	equ	12

	link	a5,#.stckframesize
	movem.l	d1-d2/a3-a4,-(sp)

	movea.l	.TEInfo(a5),a3
	move.l	.position(a5),d2

	movea.l	a3,a4
	moveq.l	#0,d0

.nxtnde	TSTNODE	a4,a4
	beq.w	.exit
	TSTNODE	a4,a0		; scan next
	beq.b	.lstnde
	cmp.w	ew_FirstChar(a0),d2
	bge.b	.nxtnde
	bra.b	.exit

.lstnde	move.w	tei_textLength(a3),d1
	cmp.w	ew_LastChar(a4),d1
	beq.b	.go_on
	cmp.w	ew_LastChar(a4),d2
	bge.b	.exit
	
.go_on	movea.l	a4,d0

.exit	movem.l	(sp)+,d1-d2/a3-a4
	unlk	a5
	rts



;-------------------------------------------------------------------------
; func: UWORD TECaretPos( struct EditWindow *, MouseX, MouseY )
;-------------------------------------------------------------------------
; Determine cursor position from mousepointer in current window
;-------------------------------------------------------------------------

_TECaretPos

.stcktemp	equ	-2
.stckframesize	equ	-2

.EditWindow	equ	8
.MouseX		equ	14
.MouseY		equ	18

	link	a5,#.stckframesize
	movem.l	d1-d5/a0-a4,-(sp)

	movea.l	.EditWindow(a5),a4

	moveq.l	#0,d0
	cmpa.w	#0,a4
	beq.w	.exit

	movea.l	ew_teInfo(a4),a3

	move.w	.MouseY(a5),d5
	sub.w	ew_Y(a4),d5
	move.w	ew_TopMargin(a4),d4

	move.w	ew_FirstChar(a4),d2
	bsr.w	teWhichCursorLine

.line	move.w	0(a0,d1.w),d2
	move.w	2(a0,d1.w),d3
	cmp.w	d2,d3
	beq.w	.last

	bsr.w	teCalcLineHeight

	add.w	d3,d4
	add.w	ew_ySpacing(a4),d4

	cmp.w	d5,d4
	bgt.b	.char	

	move.w	2(a0,d1.w),d3
	cmp.w	ew_LastChar(a4),d3
	bgt.b	.char
	addq.w	#2,d1
	bra.b	.line

.char	move.w	.MouseX(a5),d5			; get X mouse position
	sub.w	ew_X(a4),d5
	move.w	ew_LeftMargin(a4),d4
	cmp.b	#JUSTIFICATION_LEFT,ew_justification(a4)
	beq.b	.skip01

.dojust	movem.w	d2-d3,-(sp)
	bsr.w	teCalcLineWidth
	move.w	ew_Width(a4),d4
	sub.w	ew_RightMargin(a4),d4
	cmp.b	#JUSTIFICATION_RIGHT,ew_justification(a4)
	beq.b	.justRI

.justCE	sub.w	ew_LeftMargin(a4),d4
	lsr.w	#1,d4
	add.w	ew_LeftMargin(a4),d4
	lsr.w	#1,d3
	sub.w	d3,d4
	bra.b	.endjst

.justRI	sub.w	d3,d4

.endjst	movem.w	(sp)+,d2-d3


.skip01	move.w	0(a0,d1.w),d0
	move.w	2(a0,d1.w),d1
	movea.l	tei_text(a3),a0
	moveq.l	#0,d2
	lsl.w	#tec_SHIFTSIZE,d0
	lsl.w	#tec_SHIFTSIZE,d1
	cmp.w	d0,d1
	beq.b	.ok2

.skip04	cmp.w	d0,d1
	bls.b	.ok
	lea.l	(a0,d0.w),a1
	cmpi.b	#LF,tec_charCode(a1)
	beq.b	.ok2
	 move.w	d1,-(sp)
	 cmpi.b	#31,tec_charCode(a1)
	 bhi.b	.skip05
	 move.w	#4,d1
	 bra.b	.skip06
.skip05	 bsr.w	teCharWidth
.skip06	 add.w	d1,d4
	 add.w	ew_xSpacing(a4),d4
	 move.w	(sp)+,d1
	cmp.w	d5,d4
	bhi.b	.ok
	add.w	#tec_SIZE,d0
	bra.b	.skip04

.ok	cmpi.b	#' ',tec_charCode-tec_SIZE(a0,d0.w)
	bne.b	.ok2
;	subq.w	#tec_SIZE,d1
	cmp.w	d0,d1
	bne.b	.ok2
	sub.w	#tec_SIZE,d0
.ok2	lsr.w	#tec_SHIFTSIZE,d0

.exit	movem.l	(sp)+,d1-d5/a0-a4
	unlk	a5
	rts

.last	move.w	d2,d0
	bra.b	.exit





;-------------------------------------------------------------------------
; automatical source and object module updating
;-------------------------------------------------------------------------

	AUTO	u\
	AUTO	wl pascal:txed.o\y

;-- END OF FILE ----------------------------------------------------------

