/********************************************************
*File : synchromltc.c
*		All synchronizing is controlled from this
*		piece of coding.
*		Messages are send to the guides
*		resident/non-reentrant 
*
*		It is possible for workers to gain access to the synchronizer
*		but only whenever there has to be a precise synchro job. 
*/


#include <proto/cia.h>
#include <proto/battmem.h>
#include <resources/battmem.h>
#include <resources/cia.h>
#include <resources/ciabase.h>
#include <hardware/cia.h>
#include <workbench/startup.h>
#include <exec/types.h>
#include <libraries/dosextens.h>

#include "nb:pre.h"
#include "minc:types.h"
#include "minc:defs.h"
#include "minc:Errors.h"
#include "minc:process.h"
#include "minc:ge.h"
#include "minc:sync.h"
#include "minc:external.h"
#include "external.h"

#define _PRINTF FALSE
#define ed_Sig_ItoS ed_Sig_ItoGE

extern void *Int_IEServer();

#define STARTCUROBJ 	0x10		
#define STOPCUROBJ 		0x20
#define STARTPAROBJ 	0x30		// Low nibble is used as F-key identifier 0 = F1
#define STOPPAROBJ 		0x40

extern SYNCDATA ITCSyncData;		// internal generated timecode


extern struct ScriptInfoRecord *SIR;
extern PROCESSINFO	*ThisPI;


extern struct List 	*TRList;	// List of TIMECODEs which have to be checked
								// every time a timecode comes in
extern struct List	*SGList;	// List of guides that have filed a sync request
								// when SyncCollision has to be send, the PI of
								// that guide is first searched for in this list
								// If it isn't available then the SYNCCOL will not
								// be send to the guide but will simply be removed
								// This check is needed because of the fact that
								// a guide may have terminated itself BEFORE it has
								// received all SYNCCOL infos. Else it would be 
								// possible to send SYNCCOLS to non-existing guides
								// which will lead to system crashes etc. 
								// type : NT_SYNCGUIDE

extern ULONG		SigR_StoPC,		// signal used to get reply from guides.
					Sig_PCtoS,		// signal used to indicate a SyncDial msg from a guide.
 					Sig_TCItoS,		// The timecode interrupts sends us information
					SigRecvd;		// Signals received
extern struct MsgPort  *Port_StoPC,
					*Port_PCtoS,	// Port through which guides may send SyncDialogues.
				 	*RepP_StoPC;	// Reply port to which guides must reply after 
									// receiving a SyncDialogue msg from the synchronizer
extern SYNCGUIDE	*SyncGuide,		// temp var
					*NextSyncGuide;
extern SYNCPUNCH	*SyncPunch;		// temp var 
extern SYNCDIALOGUE	*Msg_RSyncDial,	// Received sync dialogue from a guide
					*Msg_SyncDial;	// dialogue sent to the guide
extern TIMEREQUEST	*Msg_Timer,
					*Msg_RTimer;
extern BOOL			RemoveOK, 
					TermOK;


extern int		SigNum_TCItoS;
struct Interrupt Int_SyncEProc;
struct IOStdReq *InputRequestBlock;
struct MsgPort	*Port_IDtoIEI;	// Port for input device to InputEventInterrupt
int				SigNum_ItoS;
EVENTDATA 		SEventData; 	// Data field for both the Int_SyncEProc and 
								// the SEventTask

int OutStanding;

/*********************************************************
*Func : Return a Punch to its owner
*in   : SGList -> Ptr to guide list
*		Msg_Timer -> As from the timer device, only this time
*					 it is generated by ourself
*		RepP_StoPC -> to which port should the PC reply
*		Port_StoPC -> to get through to the proccont
*out  : -
*/
void ReturnPunch( SGList, Msg_Timer, RepP_StoPC, Port_StoPC)
struct List *SGList;
TIMEREQUEST *Msg_Timer;
struct MsgPort *RepP_StoPC;
struct MsgPort *Port_StoPC;
{
  SYNCDIALOGUE	*Msg_SyncDial;	// dialogue sent to the guide
  SYNCGUIDE		*SyncGuide;		// temp var

	if( (SyncGuide = FindSyncGuide(SGList, Msg_Timer->tr_ProcInfo)) != NULL)
	{
		SyncGuide->sg_NrPunches--;
		if( (Msg_SyncDial = (SYNCDIALOGUE *)AllocMem(sizeof(SYNCDIALOGUE), MEMF_PUBLIC|MEMF_CLEAR)) != NULL)
		{
			OutStanding++;
#if _PRINTF
			printf("alloc %d\n",sizeof(SYNCDIALOGUE));
#endif
			Msg_SyncDial->sd_Msg.mn_Node.ln_Type = NT_MESSAGE;
			Msg_SyncDial->sd_Msg.mn_Node.ln_Pri = 0;
			Msg_SyncDial->sd_Msg.mn_Node.ln_Name = NULL;
			Msg_SyncDial->sd_Msg.mn_ReplyPort = RepP_StoPC;
			Msg_SyncDial->sd_Cmd = SDI_PUNCHCOL;
			Msg_SyncDial->sd_Punch = Msg_Timer->tr_Punch;
#if _PRINTF
			printf("Returning Punch %08lx, ptype = %ld\n",(ULONG)Msg_Timer->tr_Punch,Msg_Timer->tr_Punch->sp_PunchType);
#endif
			Msg_SyncDial->sd_TimeReq = Msg_Timer;
			PutMsg(Port_StoPC,Msg_SyncDial);
			Remove((struct Node *)Msg_Timer);
		}
		else		
		{
			Remove((struct Node *)Msg_Timer);
			FreeMem(Msg_Timer,sizeof(TIMEREQUEST));
#if _PRINTF
			printf("Removed %x, Freed %d\n",(int)Msg_Timer,sizeof(TIMEREQUEST));
#endif
		}
	}
}
/********************************************************
*Func : Tempo editor for internal midi time code hh:mm:ss:ff
*in   : -
*out  : -
*/
void TempoEditor( void)
{
  BOOL B_ProcessKey;
  int StopFKey, StartFKey;
  int InputDeviceErr,
	  ITCOk;
  ULONG CurFC;

	SIR->timeCodeSource = TIMESOURCE_INTERNAL;

	OutStanding = 0;
	Port_StoPC = NULL;
	Port_PCtoS = NULL;
	RepP_StoPC = NULL;
	SGList = NULL;
	TRList = NULL;
	SigNum_TCItoS = -1;
	ITCOk = TRUE; 
	SigNum_ItoS = -1;
	Port_IDtoIEI = NULL;
	InputRequestBlock = NULL;
	InputDeviceErr = 0;

	if( 
		((Port_StoPC = (struct MsgPort *)FindPort("Port_StoPC")) == NULL) ||
		((Port_PCtoS = CreatePort("Port_Synchro",0)) == NULL) ||
		((RepP_StoPC = CreatePort(0,0)) == NULL) ||
		((SGList = (struct List *)AllocMem(sizeof(struct List), MEMF_PUBLIC|MEMF_CLEAR)) == NULL) ||
		((TRList = (struct List *)AllocMem(sizeof(struct List), MEMF_PUBLIC|MEMF_CLEAR)) == NULL) ||
		((SigNum_TCItoS = AllocSignal(-1)) == -1) ||
		(!(ITCOk = InitITCInt(SIR, Sig_TCItoS = 1<<SigNum_TCItoS))) ||
		((SigNum_ItoS = AllocSignal(-1)) == -1) ||
		((Port_IDtoIEI = CreatePort("Port_IDtoSyncIEI",0)) == NULL) ||
		((InputRequestBlock = (struct IOStdReq *)CreateStdIO(Port_IDtoIEI)) == NULL) ||
		((InputDeviceErr = OpenDevice("input.device",0,InputRequestBlock,0)) != 0)
	  )
		goto End;

	Sig_PCtoS =  1 << Port_PCtoS->mp_SigBit;
	SigR_StoPC = 1 << RepP_StoPC->mp_SigBit;
 	NewList(SGList);
 	NewList(TRList);
	ITCSyncData.sd_TRList = TRList;

	SEventData.ed_Sig_ItoS = 1 << SigNum_ItoS;
	SEventData.ed_Task = ThisPI->pi_Process;

    Int_SyncEProc.is_Data = (APTR)&SEventData;
    Int_SyncEProc.is_Code = (void *)Int_IEServer;
    Int_SyncEProc.is_Node.ln_Pri = 60;
    Int_SyncEProc.is_Node.ln_Name = "Int_SyncEProc";
 
    InputRequestBlock->io_Command = IND_ADDHANDLER;
    InputRequestBlock->io_Data = (APTR)&Int_SyncEProc;
    DoIO(InputRequestBlock);

	StopFKey = 1;
	StartFKey = 1;
	ITCSyncData.sd_B_DoCheck = FALSE;
	ThisPI->pi_Arguments.ar_RetErr = NO_ERROR;
	RemoveOK = TermOK = FALSE;
	SigRecvd = 0;

	B_ProcessKey = TRUE;

	while(!TermOK)
	{
		SigRecvd = Wait(Sig_TCItoS|Sig_PCtoS|SigR_StoPC|SEventData.ed_Sig_ItoS|SIGF_ABORT);

		if(SigRecvd & SIGF_ABORT)
		{
			for(Msg_Timer = (TIMEREQUEST *)TRList->lh_Head;
				Msg_Timer->tr_Node.ln_Succ != NULL;
				Msg_Timer = (TIMEREQUEST *)Msg_Timer->tr_Node.ln_Succ)
			{
				Msg_Timer->tr_Punch->sp_PunchType = PT_NOPUNCH;
			}
			ITCSyncData.sd_B_DoCheck = TRUE;
			RemoveOK = TRUE;
		}

		if(SigRecvd & Sig_TCItoS)
		{
			for(Msg_RTimer = (TIMEREQUEST *)TRList->lh_Head;
				Msg_RTimer->tr_Node.ln_Succ != NULL;
				Msg_RTimer = (TIMEREQUEST *)Msg_RTimer->tr_Node.ln_Succ)
			{
				if(Msg_RTimer->tr_ColState == CS_FRAMECOL)
				{
					Msg_RTimer->tr_ColState = CS_TRANSMITTED;
					// take the SyncPunch from the message.ln_name and send it to its
					// original guide.

					ReturnPunch(SGList,Msg_RTimer,RepP_StoPC,Port_StoPC);
				}
			}
		}
		// Signal from Proccont
		if(SigRecvd & Sig_PCtoS)
		{
			// Get new punches
			while( (Msg_RSyncDial = (SYNCDIALOGUE *)GetMsg((struct MsgPort *)Port_PCtoS)) != NULL)
			{
				// In case of new syncpunches, get them from the dialogue and send
				// them out to the ITC interrupt.
				if(Msg_RSyncDial->sd_Cmd == SDC_NEWPUNCH)
				{
					Msg_RSyncDial->sd_Cmd = SDI_PUNCHACCEPTED;
					// see if this guide has more syncpunches active

					if((SyncGuide = FindSyncGuide(SGList,Msg_RSyncDial->sd_ProcInfo)) == NULL)
					{
						// allocate mem for the SyncGuide
						if( (SyncGuide = (SYNCGUIDE *)AllocMem(sizeof(SYNCGUIDE), MEMF_PUBLIC|MEMF_CLEAR)) == NULL)
							Msg_RSyncDial->sd_Cmd = SDI_PUNCHERROR;	// severe problems, reply an error
						else
						{
							SyncGuide->sg_Node.ln_Type = NT_SYNCGUIDE; 
							SyncGuide->sg_Node.ln_Pri = 0; 
							SyncGuide->sg_Node.ln_Name = NULL; 
							SyncGuide->sg_NrPunches = 0;
							SyncGuide->sg_ProcInfo = Msg_RSyncDial->sd_ProcInfo;
							// insert the new syncguide into the SGList
							AddHead((struct List *)SGList,(struct Node *)SyncGuide);
						}
					}

					if(SyncGuide != NULL)
					{
						for(SyncPunch = Msg_RSyncDial->sd_Punch;
							SyncPunch != NULL;
							SyncPunch = (SYNCPUNCH *)SyncPunch->sp_MinNode.mln_Succ)
						{
							// not used, simply counts the number of punches filed
							SyncGuide->sg_NrPunches++;
							// allocate mem for the timerequest
							if( (Msg_Timer = (TIMEREQUEST *)AllocMem(sizeof(TIMEREQUEST), MEMF_PUBLIC|MEMF_CLEAR)) == NULL)
							{
								// severe problems, reply an error 
								Msg_RSyncDial->sd_Cmd = SDI_PUNCHERROR;
							}
							else
							{
								// insert the new Timerequest into the TRList
								Msg_Timer->tr_ColState = CS_WAIT;
								Msg_Timer->tr_Node.ln_Type = NT_TIMEREQUEST;
								Msg_Timer->tr_ProcInfo = Msg_RSyncDial->sd_ProcInfo;
#if _PRINTF
								printf("from pc: syncpunch type = %ld\n",SyncPunch->sp_PunchType);
								printf("from pc: Msg_Timer at %lx\n",(int)Msg_Timer);
#endif
								if(RemoveOK)
									SyncPunch->sp_PunchType = PT_NOPUNCH;

								Msg_Timer->tr_Punch = SyncPunch;
								AddHead((struct List *)TRList,(struct Node *)Msg_Timer);

								// Start punches of objects that are not a part of
								// a PARALLEL event should be returned right now.
								// Objects belonging to a PARALLEL events are 
								// put under Functions-keys.
								if(SyncPunch->sp_SNR->ParentSNR->nodeType == TALK_STARTPAR)
								{
									// Assign a Function key to the punch
									if(SyncPunch->sp_PunchType == PT_DORUN)
										SyncPunch->sp_FKey = StartFKey++;
									if(SyncPunch->sp_PunchType == PT_DOSTOP)
										SyncPunch->sp_FKey = StopFKey++;
								}	
								else
								{
									if(SyncPunch->sp_PunchType == PT_DORUN)
									{
										CurFC = ITCSyncData.sd_FCFastCheck;
										SyncPunch->sp_SNR->Start.TimeCode.HH = (UBYTE)((CurFC>>24) & 0xff);
										SyncPunch->sp_SNR->Start.TimeCode.MM = (UBYTE)((CurFC>>16) & 0xff);
										SyncPunch->sp_SNR->Start.TimeCode.SS = (UBYTE)((CurFC>>8) & 0xff);
										SyncPunch->sp_SNR->Start.TimeCode.FF = (UBYTE)CurFC & 0xff;
									}
								}	
							}
						}	

						Forbid();					
						for(Msg_Timer = (TIMEREQUEST *)TRList->lh_Head;
							Msg_Timer->tr_Node.ln_Succ != NULL;
							Msg_Timer = (TIMEREQUEST *)Msg_Timer->tr_Node.ln_Succ)
						{
#if _PRINTF
							printf("tmr = %lx\n",(ULONG)Msg_Timer);
							printf("punch = %lx\n",(ULONG)Msg_Timer->tr_Punch);
							printf("Snr = %lx\n",(ULONG)Msg_Timer->tr_Punch->sp_SNR);
							printf("pSnr = %lx\n",(ULONG)Msg_Timer->tr_Punch->sp_SNR->ParentSNR);
#endif
							if(Msg_Timer->tr_Punch->sp_SNR->ParentSNR->nodeType == TALK_STARTSER)
								if(Msg_Timer->tr_Punch->sp_PunchType == PT_DORUN)
									ReturnPunch(SGList,Msg_Timer,RepP_StoPC,Port_StoPC);
						}
						Permit();


					} // if(SyncGuide != NULL)
					if(SIR->timeCodeSource == TIMESOURCE_INTERNAL)
						ITCSyncData.sd_B_Count = TRUE;
				}
				else
				{
					// a guide wants to be removed from the SyncGuide chain
					if(Msg_RSyncDial->sd_Cmd == SDC_GUIDETERM)
					{
						if( (SyncGuide = FindSyncGuide(SGList,Msg_RSyncDial->sd_ProcInfo)) != NULL)
						{
							Remove((struct Node *)SyncGuide);
							FreeMem(SyncGuide, sizeof(SYNCGUIDE));
						}
						Msg_RSyncDial->sd_Cmd = SDI_GUIDEREMOVED;
					}
					else
					{
						if(Msg_RSyncDial->sd_Cmd == SDC_ABORTPUNCHES)
						{
							// this message normally comes from the processcontroller
							// We need to abort all outstanding messages
							Msg_RSyncDial->sd_Cmd = SDI_PUNCHESABORTED;
							// Abort all outstanding Timer messages
							Disable();
							for(Msg_Timer = (TIMEREQUEST *)TRList->lh_Head;
								Msg_Timer->tr_Node.ln_Succ != NULL;
								Msg_Timer = (TIMEREQUEST *)Msg_Timer->tr_Node.ln_Succ)
								Msg_Timer->tr_Punch->sp_PunchType = PT_NOPUNCH;
							Enable();
						}
						else
						{
							if(Msg_RSyncDial->sd_Cmd == SDC_SETTIMECODE)
							{
								Msg_RSyncDial->sd_Cmd = SDI_TIMECODESET;
								ITCSyncData.sd_FCFastCheck = (ULONG)Msg_RSyncDial->sd_Punch;
							}
							else
							{
								if(Msg_RSyncDial->sd_Cmd == SDC_GETTIMECODE)
								{
									Msg_RSyncDial->sd_Cmd = SDI_TIMECODEGET;
									Msg_RSyncDial->sd_Punch = (SYNCPUNCH *)ITCSyncData.sd_FCFastCheck;
								}
								else if(Msg_RSyncDial->sd_Cmd == SDC_GETTIMECODE_ASC)
								{
									Msg_RSyncDial->sd_Cmd = SDI_TIMECODEGET_ASC;
									Msg_RSyncDial->sd_Punch = (SYNCPUNCH *)ITCSyncData.sd_FCFastCheck;
								}
							}
						}
					}
				}
				ReplyMsg((struct Message *)Msg_RSyncDial);
			}
		}
		// If a key was hit then find out for what punch the key is for
		if(B_ProcessKey)
		{
			if(SigRecvd & SEventData.ed_Sig_ItoS)
			{
				// get current frame time
				CurFC = ITCSyncData.sd_FCFastCheck;
#if _PRINTF
				printf("Frame = %08x, Cmd = %d\n",(int)CurFC,(int)SEventData.ed_Cmd);
#endif
				if(SEventData.ed_Cmd == STOPCUROBJ)
				{
#if _PRINTF
					printf("Cmd = StopCurObj\n");
#endif
					StopFKey = 1;
					StartFKey = 1;

					// Return all STOP/START punches
					for(Msg_Timer = (TIMEREQUEST *)TRList->lh_Head;
						Msg_Timer->tr_Node.ln_Succ != NULL;
						Msg_Timer = (TIMEREQUEST *)Msg_Timer->tr_Node.ln_Succ)
					{
#if _PRINTF
						printf("PT = %d\n",(int)Msg_Timer->tr_Punch->sp_PunchType);
#endif
						if(Msg_Timer->tr_Punch->sp_PunchType == PT_DOSTOP)
						{
							if(Msg_Timer->tr_Punch->sp_SNR->ParentSNR->nodeType == TALK_STARTSER)
							{
								Msg_Timer->tr_Punch->sp_SNR->End.TimeCode.HH = (UBYTE)((CurFC>>24) & 0xff);
								Msg_Timer->tr_Punch->sp_SNR->End.TimeCode.MM = (UBYTE)((CurFC>>16) & 0xff);
								Msg_Timer->tr_Punch->sp_SNR->End.TimeCode.SS = (UBYTE)((CurFC>>8) & 0xff);
								Msg_Timer->tr_Punch->sp_SNR->End.TimeCode.FF = (UBYTE)CurFC & 0xff;
							}	
							else
								Msg_Timer->tr_Punch->sp_SNR->End.ParHMSTOffset = CurFC;
						}

						if(Msg_Timer->tr_Punch->sp_PunchType == PT_DORUN)
						{
							// Make sure the object for the punch doesn't start
							Msg_Timer->tr_Punch->sp_PunchType = PT_NOPUNCH;
						}
						ReturnPunch(SGList,Msg_Timer,RepP_StoPC,Port_StoPC);
					}
				}
				if((SEventData.ed_Cmd & STARTPAROBJ) == STARTPAROBJ)
				{
					// Return all STOP/START punches
					for(Msg_Timer = (TIMEREQUEST *)TRList->lh_Head;
						Msg_Timer->tr_Node.ln_Succ != NULL;
						Msg_Timer = (TIMEREQUEST *)Msg_Timer->tr_Node.ln_Succ)
					{
						if(Msg_Timer->tr_Punch->sp_PunchType == PT_DORUN)
						{
							if( (Msg_Timer->tr_Punch->sp_FKey - 1) == (SEventData.ed_Cmd & 0x0f))
							{
								Msg_Timer->tr_Punch->sp_SNR->Start.ParHMSTOffset = CurFC;
								ReturnPunch(SGList,Msg_Timer,RepP_StoPC,Port_StoPC);
							}
						}
					}
				}

				if((SEventData.ed_Cmd & STOPPAROBJ) == STOPPAROBJ)
				{
					// Return all STOP/START punches
					for(Msg_Timer = (TIMEREQUEST *)TRList->lh_Head;
						Msg_Timer->tr_Node.ln_Succ != NULL;
						Msg_Timer = (TIMEREQUEST *)Msg_Timer->tr_Node.ln_Succ)
					{
						if(Msg_Timer->tr_Punch->sp_PunchType == PT_DOSTOP)
						{
							if( (Msg_Timer->tr_Punch->sp_FKey - 1) == (SEventData.ed_Cmd & 0x0f))
							{
								Msg_Timer->tr_Punch->sp_SNR->End.ParHMSTOffset = CurFC;
								ReturnPunch(SGList,Msg_Timer,RepP_StoPC,Port_StoPC);
							}
						}
					}
				}
				B_ProcessKey = FALSE;
			}
		}


		if(SigRecvd & SigR_StoPC)
		{
			B_ProcessKey = TRUE;
			// the pc replied to our dialogue, free its mem
			while( (Msg_RSyncDial = (SYNCDIALOGUE *)GetMsg((struct MsgPort *)RepP_StoPC)) != NULL)
			{
				OutStanding--;
#if _PRINTF
				printf("removed Msg_Timer at %x\n",(int)Msg_RSyncDial->sd_TimeReq);
#endif
				if(Msg_RSyncDial->sd_TimeReq != NULL)
					FreeMem(Msg_RSyncDial->sd_TimeReq,sizeof(TIMEREQUEST));

				FreeMem(Msg_RSyncDial,sizeof(SYNCDIALOGUE));
			}
		}

		if(RemoveOK)
			if(
				((struct List *)TRList->lh_TailPred == (struct List *)TRList) &&
				(OutStanding == 0)
			  )
				TermOK = TRUE;
			else
			{
				Signal(ThisPI->pi_Process,SIGF_ABORT);
			}
	}	

End:
	if(InputRequestBlock != NULL)
	{
		InputRequestBlock->io_Command = IND_REMHANDLER;
    	InputRequestBlock->io_Data = (APTR)&Int_SyncEProc;
	   	DoIO(InputRequestBlock);
		if(InputDeviceErr == 0)
	    	CloseDevice(InputRequestBlock);
		DeleteStdIO(InputRequestBlock);
	}
	if(Port_IDtoIEI != NULL)
		DeletePort(Port_IDtoIEI);
	if(SigNum_ItoS == -1)
		FreeSignal(SigNum_ItoS);
	if(ITCOk)
		FreeITCInt(SIR);
	if(SigNum_TCItoS == -1)
		FreeSignal(SigNum_TCItoS);

	SyncGuide = (SYNCGUIDE *)SGList->lh_Head;
	while( NextSyncGuide = (SYNCGUIDE *)SyncGuide->sg_Node.ln_Succ)
	{
		FreeMem(SyncGuide, sizeof(SYNCGUIDE));
		SyncGuide = NextSyncGuide;
	}
	if(TRList != NULL)
		FreeMem(TRList, sizeof(struct List));
	if(SGList != NULL)
		FreeMem(SGList, sizeof(struct List));
	if(RepP_StoPC != NULL)
		DeletePort(RepP_StoPC);
	if(Port_PCtoS != NULL)
		DeletePort(Port_PCtoS);
}


/***************************************************
*Func : Handle the inputevent stream
*in   : InEvent -> ptr to an event
*		SEventData -> ptr to EVENTDATA struct
*out  : InEvent
*/
struct InputEvent *Int_IEHandler( InEvent, SEventData)
struct InputEvent *InEvent;
EVENTDATA *SEventData;
{
  UWORD KeyCode;
  UWORD Qual;

	switch(InEvent->ie_Class)
	{
	    case IECLASS_RAWKEY:
	    	KeyCode = (UWORD)InEvent->ie_Code;
			Qual = InEvent->ie_Qualifier;

			// check special preprogrammed keys
			switch(KeyCode)
			{
				case 0x4e:	//crsr right
						InEvent->ie_Class = IECLASS_NULL;
						SEventData->ed_Cmd = STOPCUROBJ;
						Signal(SEventData->ed_Task,SEventData->ed_Sig_ItoS);
						break;
			}
			if(KeyCode >= 0x50 && KeyCode <= 0x59)
			{
				InEvent->ie_Class = IECLASS_NULL;
				if(Qual & (IEQUALIFIER_LSHIFT|IEQUALIFIER_RSHIFT|IEQUALIFIER_CAPSLOCK))
					SEventData->ed_Cmd = STOPPAROBJ|(KeyCode & 0x0f);
				else
					SEventData->ed_Cmd = STARTPAROBJ|(KeyCode & 0x0f);

				Signal(SEventData->ed_Task,SEventData->ed_Sig_ItoS);
			}
			break;
	    case IECLASS_RAWMOUSE:
		    KeyCode = (UWORD)InEvent->ie_Code;
			switch(KeyCode)
			{
				case IECODE_RBUTTON:
						InEvent->ie_Class = IECLASS_NULL;
						SEventData->ed_Cmd = STOPCUROBJ;
						Signal(SEventData->ed_Task,SEventData->ed_Sig_ItoS);
						break;
			}
			break;
		default:
			break;
	}

	return(InEvent);
}
